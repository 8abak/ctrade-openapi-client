<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Review</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --bg:#0b1622; --fg:#d7e1ea; --mut:#8fa1b3; --grid:#243447; --axis:#5f7287;
          --mid:#9db4ff; --bid:#8bd6ff; --ask:#a8ffb5; --micro:#ffd166; --medi:#ef476f; --maxi:#06d6a0; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  .topbar{display:flex;gap:.75rem;align-items:center;padding:.5rem .75rem;border-bottom:1px solid var(--grid);position:sticky;top:0;background:rgba(11,22,34,.96);z-index:20}
  .topbar input{width:110px;background:#0e1b29;border:1px solid #294058;border-radius:6px;color:var(--fg);padding:.4rem .5rem}
  .btn{background:#12263a;border:1px solid #2d4a61;border-radius:8px;color:var(--fg);padding:.45rem .75rem;cursor:pointer}
  .btn:hover{background:#163048}
  .hint{margin-left:auto;color:var(--mut)}
  .legend{display:flex;gap:1rem;align-items:center;padding:.35rem .75rem;border-bottom:1px solid var(--grid)}
  .legend label{display:inline-flex;gap:.4rem;align-items:center;cursor:pointer}
  .chip{display:inline-block;width:.8rem;height:.8rem;border-radius:50%}
  .chip.mid{background:var(--mid)} .chip.bid{background:var(--bid)} .chip.ask{background:var(--ask)}
  .chip.micro{background:var(--micro)} .chip.medi{background:var(--medi)} .chip.maxi{background:var(--maxi)}
  #chart{height:calc(100vh - 132px)}
  svg{width:100%;height:100%;display:block}
  .axis path,.axis line{stroke:var(--axis)}
  .grid line{stroke:var(--grid)}
  .line{fill:none;stroke-width:1.5px}
  .line.mid{stroke:var(--mid)} .line.bid{stroke:var(--bid)} .line.ask{stroke:var(--ask)}
  .zig.micro{stroke:var(--micro)} .zig.medi{stroke:var(--medi)} .zig.maxi{stroke:var(--maxi)}
  .tooltip{position:absolute;pointer-events:none;background:#0f1f2f;border:1px solid #2d4a61;border-radius:8px;padding:.5rem .6rem;color:var(--fg);box-shadow:0 8px 24px rgba(0,0,0,.35)}
  .crosshair line{stroke:#6a7f94;stroke-dasharray:4 4}
  .status{padding:.35rem .75rem;border-top:1px solid #213447;background:#0e1a27;color:#9ec3ff;font-size:12px}
  .status b{color:#ffd166}
  .status .err{color:#ffb4b4}
</style>
</head>
<body>
  <div class="topbar">
    <label>Start ID <input id="startId" type="number" value="1" /></label>
    <label>Chunk size <input id="chunk" type="number" value="2000" /></label>
    <button id="btnLoad" class="btn">Load</button>
    <button id="btnMore" class="btn">Load more (right)</button>
    <div class="hint">Legend toggles below • Zoom: <b>Shift+wheel</b> • Pan: <b>wheel</b></div>
  </div>
  <div class="legend" id="legend"></div>
  <div id="chart"></div>
  <div class="tooltip" id="tip" style="display:none"></div>
  <div class="status" id="status">Ready.</div>

<!-- d3 FIRST -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script>
/* -------------- status line -------------- */
const setStatus = (html) => document.getElementById('status').innerHTML = html;

/* -------------- helpers -------------- */
const $ = s => document.querySelector(s);
const niceInt = d3.format("~d");
const fmtDT = ts => { const d=new Date(ts); return {date:d.toLocaleDateString(), time:d.toLocaleTimeString()}; };

/* -------------- endpoint auto-fallback -------------- */
async function fetchFirstOK(urls, label){
  let lastErr, lastUrl;
  for (const u of urls){
    lastUrl = u;
    try {
      const r = await fetch(u);
      if (!r.ok) { lastErr = new Error(`HTTP ${r.status}`); continue; }
      const j = await r.json();
      setStatus(`<b>${label}</b> ✓ ${u}`);
      return j;
    } catch(e){
      lastErr = e;
    }
  }
  setStatus(`<b>${label}</b> <span class="err">failed</span> — tried: ${urls.map(x=>`<code>${x}</code>`).join(', ')}`);
  throw lastErr || new Error('No endpoint matched');
}

// candidate patterns
const ticksURLs = (start,limit) => [
  `/api/ticks?start=${start}&limit=${limit}`,
  `/ticks?start=${start}&limit=${limit}`,
  `/api/ticks?from=${start}&limit=${limit}`,
  `/ticks?from=${start}&limit=${limit}`,
  `/data/ticks?start=${start}&limit=${limit}`,
  `/data/ticks?from=${start}&limit=${limit}`,
];
const tablesURLs = [
  `/api/tables`,
  `/tables`,
  `/api/labels/tables`,
  `/labels/tables`,
  `/data/tables`,
];
const labelsURLs = (table,fromId,toId) => [
  `/api/labels?table=${encodeURIComponent(table)}&from=${fromId}&to=${toId}`,
  `/labels?table=${encodeURIComponent(table)}&from=${fromId}&to=${toId}`,
  `/api/labels/${encodeURIComponent(table)}?from=${fromId}&to=${toId}`,
  `/labels/${encodeURIComponent(table)}?from=${fromId}&to=${toId}`,
  `/api/labels?table=${encodeURIComponent(table)}&start_id=${fromId}&end_id=${toId}`,
  `/labels?table=${encodeURIComponent(table)}&start_id=${fromId}&end_id=${toId}`,
  `/data/labels?table=${encodeURIComponent(table)}&from=${fromId}&to=${toId}`,
];

async function fetchTicks(start, limit){ return fetchFirstOK(ticksURLs(start,limit), 'ticks'); }
async function fetchTables(){
  const arr = await fetchFirstOK(tablesURLs, 'tables');
  if (Array.isArray(arr) && typeof arr[0]==='string') return arr.filter(n=>n!=='ticks');
  if (Array.isArray(arr) && arr[0]?.name) return arr.map(x=>x.name).filter(n=>n!=='ticks');
  return [];
}
async function fetchLabelsWindow(table,fromId,toId){ return fetchFirstOK(labelsURLs(table,fromId,toId), `labels:${table}`); }

/* -------------- state -------------- */
let ticks=[], ticksMap=new Map();
let loadedFrom=null, loadedTo=null, zoomX=null;
let layersMeta={};   // {name:{type:'tick'|'zig',active:true}}
let zigData={};      // {name:[{start_id,end_id,start_ts,end_ts,...}]}
const COLORS={ mid:'var(--mid)', bid:'var(--bid)', ask:'var(--ask)', micro:'var(--micro)', medi:'var(--medi)', maxi:'var(--maxi)' };

/* -------------- data mechanics -------------- */
function indexTicks(arr){ for(const t of arr) ticksMap.set(t.id,t); }
function updateLoadedBounds(){ if (ticks.length){ loadedFrom=ticks[0].id; loadedTo=ticks[ticks.length-1].id; } }

async function doLoad(startId, chunk){
  const arr = await fetchTicks(startId, chunk);
  if (!Array.isArray(arr) || !arr.length){ setStatus('<span class="err">No ticks returned</span>'); return; }
  ticks=arr; ticksMap=new Map(); indexTicks(arr); updateLoadedBounds();
  await refreshZigsForWindow();
  zoomX=[loadedFrom,loadedTo];
  render();
}

async function doLoadMoreRight(){
  if (loadedTo==null) return;
  const chunk=+$('#chunk').value||2000;
  const arr=await fetchTicks(loadedTo+1, chunk);
  if (!arr.length) return;
  ticks=ticks.concat(arr); indexTicks(arr); updateLoadedBounds();
  const keep0=Math.round(zoomX?.[0]??loadedFrom); const keep1=Math.round(zoomX?.[1]??loadedTo);
  await refreshZigsForWindow();
  zoomX=[keep0,keep1];
  render();
}

async function initLayers(){
  layersMeta={ mid:{type:'tick',active:true}, bid:{type:'tick',active:true}, ask:{type:'tick',active:true} };
  try{
    const names=await fetchTables();
    const fromId=loadedFrom??1, toId=loadedTo??(fromId+5000);
    for (const name of names){
      try{
        const rows=await fetchLabelsWindow(name, fromId, toId);
        const isZig = rows.length && ['start_id','end_id','start_ts','end_ts'].every(k=>k in rows[0]);
        layersMeta[name]={type:isZig?'zig':'tick',active:isZig};
        if (isZig) zigData[name]=rows;
      }catch(_){}
    }
  }catch(_){}
  buildLegend();
}

function buildLegend(){
  const c=$('#legend'); c.innerHTML='';
  for (const name of Object.keys(layersMeta)){
    const meta=layersMeta[name];
    const label=document.createElement('label');
    const chk=document.createElement('input'); chk.type='checkbox'; chk.checked=!!meta.active;
    chk.addEventListener('change', async ()=>{ meta.active=chk.checked; await refreshZigsForWindow(); render(); });
    const chip=document.createElement('span'); chip.className='chip '+name;
    label.appendChild(chk); label.appendChild(chip); label.appendChild(document.createTextNode(' '+name));
    c.appendChild(label);
  }
}

async function refreshZigsForWindow(){
  const fromId=loadedFrom??1, toId=loadedTo??(fromId+5000);
  for (const name of Object.keys(layersMeta)){
    if (layersMeta[name].type!=='zig' || !layersMeta[name].active) continue;
    try { zigData[name]=await fetchLabelsWindow(name, fromId, toId); } catch(_){}
  }
}

/* -------------- chart -------------- */
const svg=d3.select('#chart').append('svg');
const gMain=svg.append('g'), gGrid=gMain.append('g').attr('class','grid');
const gXAxis=gMain.append('g').attr('class','axis'), gYAxis=gMain.append('g').attr('class','axis');
const gLines=gMain.append('g').attr('clip-path','url(#clip)'), gZigs=gMain.append('g').attr('clip-path','url(#clip)');
const gCross=gMain.append('g').attr('class','crosshair');
const defs=svg.append('defs'); defs.append('clipPath').attr('id','clip').append('rect');

let x=d3.scaleLinear(), y=d3.scaleLinear();
let xAxis=d3.axisBottom(x).tickFormat(niceInt), yAxis=d3.axisLeft(y).ticks(8).tickFormat(niceInt);

function layout(){ const {width,height}=svg.node().getBoundingClientRect();
  const m={t:18,r:26,b:34,l:48}, w=width-m.l-m.r, h=height-m.t-m.b;
  gMain.attr('transform',`translate(${m.l},${m.t})`); gXAxis.attr('transform',`translate(0,${h})`);
  defs.select('#clip rect').attr('width',w).attr('height',h); return {m,w,h}; }
function domainX(){ if(!ticks.length) return [0,1]; return zoomX||[ticks[0].id,ticks[ticks.length-1].id]; }
function computeYExtent(){
  const [x0,x1]=domainX(); const vals=[];
  for(const k of ['mid','bid','ask']) if (layersMeta[k]?.active) for(const t of ticks) if(t.id>=x0&&t.id<=x1&&t[k]!=null) vals.push(t[k]);
  for(const name of Object.keys(layersMeta)){
    if(layersMeta[name]?.type!=='zig'||!layersMeta[name]?.active) continue;
    for(const leg of (zigData[name]||[])){
      const a=ticksMap.get(leg.start_id), b=ticksMap.get(leg.end_id);
      if(a&&a.id>=x0&&a.id<=x1&&a.mid!=null) vals.push(a.mid);
      if(b&&b.id>=x0&&b.id<=x1&&b.mid!=null) vals.push(b.mid);
    }
  }
  if(!vals.length) return [0,1];
  let mi=Math.min(...vals), ma=Math.max(...vals), pad=Math.max(0.25,(ma-mi)*0.05);
  return [Math.floor(mi-pad), Math.ceil(ma+pad)];
}

function render(){
  const {w,h}=layout(); const [x0,x1]=domainX(); x.domain([x0,x1]).range([0,w]);
  const [y0,y1]=computeYExtent(); y.domain([y0,y1]).range([h,0]).nice();

  gGrid.selectAll('g.vert').data(x.ticks(8)).join(
    e=>e.append('g').attr('class','vert').append('line').attr('y1',0).attr('y2',h).attr('stroke','var(--grid)'),
    u=>u, x=>x.remove()).attr('transform',d=>`translate(${x(d)},0)`);
  gGrid.selectAll('g.horz').data(y.ticks(8)).join(
    e=>e.append('g').attr('class','horz').append('line').attr('x1',0).attr('x2',w).attr('stroke','var(--grid)'),
    u=>u, x=>x.remove()).attr('transform',d=>`translate(0,${y(d)})`);
  gXAxis.call(xAxis); gYAxis.call(yAxis);

  const lineGen=k=>d3.line().x(d=>x(d.id)).y(d=>y(d[k])).defined(d=>d[k]!=null);
  for(const k of ['mid','bid','ask']){
    const on=layersMeta[k]?.active; const sel=gLines.selectAll(`path.line.${k}`).data(on?[ticks]:[]);
    sel.enter().append('path').attr('class',`line ${k}`).attr('stroke',COLORS[k])
      .merge(sel).attr('fill','none').attr('d', lineGen(k)(ticks));
    sel.exit().remove();
  }

  const names=Object.keys(layersMeta).filter(n=>layersMeta[n]?.type==='zig'&&layersMeta[n].active);
  const join=gZigs.selectAll('path.zig').data(names,d=>d);
  join.enter().append('path').attr('class',d=>`zig ${d}`).attr('fill','none').attr('stroke-width',1.8)
      .attr('stroke',d=>COLORS[d]||'#bbb').merge(join)
      .attr('d', name=>{
        const legs=(zigData[name]||[]).slice().sort((a,b)=>a.start_id-b.start_id);
        const p=d3.path(); let started=false;
        for(const leg of legs){ const a=ticksMap.get(leg.start_id), b=ticksMap.get(leg.end_id); if(!a||!b) continue;
          const Ax=x(a.id), Ay=y(a.mid); const Bx=x(b.id), By=y(b.mid);
          if(!started){ p.moveTo(Ax,Ay); started=true; } p.lineTo(Bx,By);
        }
        return started ? p.toString() : null;
      });
  join.exit().remove();

  drawCrosshair(w,h);
}

function drawCrosshair(w,h){
  const tip=$('#tip');
  svg.on('mousemove', ev=>{
    if (!ticks.length) return;
    const pt=d3.pointer(ev, svg.node()); const xpix=pt[0]-48; const idG=Math.round(x.invert(Math.max(0,Math.min(w,xpix))));
    let t=ticksMap.get(idG); if(!t){ const arr=ticks.map(d=>d.id); const i=d3.bisector(d=>d).center(arr,idG); t=ticks[i]; }
    if(!t) return; const {date,time}=fmtDT(t.timestamp);
    let html=`<div><b>ID:</b> ${t.id} &nbsp; <b>Date:</b> ${date} &nbsp; <b>Time:</b> ${time}</div>`;
    for(const k of ['mid','bid','ask']) if(layersMeta[k]?.active && t[k]!=null) html+=`<div>${k}: <b>${t[k]}</b></div>`;
    tip.innerHTML=html; tip.style.display='block'; tip.style.left=(ev.clientX+14)+'px'; tip.style.top=(ev.clientY+14)+'px';
    gCross.selectAll('*').remove(); const cy=t.mid!=null?y(t.mid):t.ask!=null?y(t.ask):t.bid!=null?y(t.bid):null;
    if(cy!=null){ const cx=x(t.id); gCross.append('line').attr('x1',cx).attr('x2',cx).attr('y1',0).attr('y2',h);
                  gCross.append('line').attr('x1',0).attr('x2',w).attr('y1',cy).attr('y2',cy); }
  }).on('mouseleave',()=>{ gCross.selectAll('*').remove(); tip.style.display='none'; });
}

/* -------------- zoom/pan -------------- */
(function(){
  svg.node().addEventListener('wheel', (e)=>{
    if (!ticks.length) return; e.preventDefault();
    const {w}=layout(); const [xmin,xmax]=domainX(); const span=xmax-xmin;
    const mouseX=d3.pointer(e, svg.node())[0]-48; const focal=x.invert(Math.max(0,Math.min(w,mouseX)));
    if (e.shiftKey){
      const factor=Math.exp(-e.deltaY*0.0015);
      let nmin=focal-(focal-xmin)*factor, nmax=focal+(xmax-focal)*factor;
      nmin=Math.max(loadedFrom, Math.min(nmin,nmax-1)); nmax=Math.min(loadedTo, Math.max(nmax,nmin+1));
      zoomX=[Math.round(nmin),Math.round(nmax)];
    } else {
      const k=e.deltaY!==0?e.deltaY:e.deltaX; const shift=Math.round(k*span/120/6);
      let nmin=Math.max(loadedFrom, xmin+shift), nmax=Math.min(loadedTo, xmax+shift);
      if(nmax-nmin<1) nmax=nmin+1; zoomX=[nmin,nmax];
    }
    render();
  }, {passive:false});
})();

/* -------------- UI -------------- */
document.getElementById('btnLoad').addEventListener('click', async ()=>{
  try{
    await doLoad(+$('#startId').value||1, +$('#chunk').value||2000);
    await initLayers(); render();
  }catch(e){ setStatus('<span class="err">Load failed (see console)</span>'); console.error(e); }
});
document.getElementById('btnMore').addEventListener('click', async ()=>{
  try{ await doLoadMoreRight(); }catch(e){ setStatus('<span class="err">Load more failed</span>'); }
});

/* -------------- first run -------------- */
(async function(){
  try{
    await doLoad(+$('#startId').value||1, +$('#chunk').value||2000);
    await initLayers(); render();
  }catch(e){ setStatus('<span class="err">Initial load failed</span>'); console.error(e); }
})();
</script>
</body>
</html>
