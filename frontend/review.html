<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ML Review — Price-Action Segments</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root{--bg:#0f172a;--panel:#111827;--ink:#e5e7eb;--muted:#94a3b8}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .toolbar{display:flex;gap:.75rem;align-items:center;padding:.6rem .8rem;background:var(--panel);position:sticky;top:0;z-index:2}
    .toolbar input[type="number"]{width:120px;background:#0b1220;border:1px solid #22304a;border-radius:8px;color:var(--ink);padding:.35rem .5rem}
    .toolbar button{background:#1f2a44;border:1px solid #334155;color:var(--ink);padding:.45rem .7rem;border-radius:8px;cursor:pointer}
    .toolbar button:hover{border-color:#4b5563}
    .layers{display:flex;align-items:center;gap:.65rem}
    .layers label{display:inline-flex;align-items:center;gap:.3rem;color:var(--muted)}
    .legend{padding:.3rem .8rem;color:var(--muted)}
    #wrap{height:calc(100% - 92px);display:flex;flex-direction:column}
    #chart{flex:1 1 auto;min-height:380px}
    .note{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="toolbar">
    <div>
      <div class="note">Start ID</div>
      <input id="startId" type="number" value="1" step="1" />
    </div>
    <div>
      <div class="note">Chunk size</div>
      <input id="chunk" type="number" value="2000" step="100" />
    </div>
    <button id="btnLoad">Load</button>
    <button id="btnMoreRight">Load more (right)</button>
    <div class="layers">
      <span class="note">Layers:</span>
      <label><input id="layMid" type="checkbox" checked /> mid</label>
      <label><input id="layBid" type="checkbox" /> bid</label>
      <label><input id="layAsk" type="checkbox" /> ask</label>
      <label><input id="layMaxi" type="checkbox" /> maxi</label>
      <label><input id="layMedi" type="checkbox" /> medi</label>
      <label><input id="layMicro" type="checkbox" checked /> micro</label>
    </div>
  </div>

  <div class="legend">Legend toggles below • Zoom: <b>Shift + wheel</b> • Pan: <b>wheel</b></div>

  <div id="wrap"><div id="chart"></div></div>

  <script>
    // ------------ CONFIG ------------
    const $ = s => document.querySelector(s);
    const PADDING = 800; // pad to cover label boundary ids
    function setBusy(on){ document.body.style.cursor = on ? 'progress' : 'default'; }
    function readControls(){ startId = +$('#startId').value; chunkSize = +$('#chunk').value; endId = startId + chunkSize - 1; }

    // ------------ STATE ------------
    let startId = +$('#startId').value;
    let chunkSize = +$('#chunk').value;
    let endId = startId + chunkSize - 1;

    // tickId -> { ts, mid, bid, ask, price }
    const tickMap = new Map();
    let midSeries=[], bidSeries=[], askSeries=[];

    const chart = echarts.init(document.getElementById('chart'));
    chart.setOption({
      darkMode:true, animation:false,
      tooltip:{ trigger:'axis', axisPointer:{ type:'cross' } },
      grid:{ left:60, right:20, top:30, bottom:110 },
      dataZoom:[ {type:'inside', filterMode:'none'}, {type:'slider', bottom:60, height:32} ],
      xAxis:{ type:'time', axisLabel:{color:'#9ca3af'} },
      yAxis:{ type:'value', scale:true, axisLabel:{color:'#9ca3af'} },
      series:[]
    });

    // ------------ FETCH (STRICT) ------------
    // Use only the shapes we've seen working: start_id/end_id or start/limit.
    async function fetchJson(url){
      const r = await fetch(url);
      const t = await r.text();
      let body; try{ body = t ? JSON.parse(t) : null; } catch{ body = t; }
      if(!r.ok) throw new Error(`${r.status} : ${url}\n${typeof body==='string'?body:JSON.stringify(body)}`);
      return body;
    }

    async function fetchTicks(sId, eId){
      const n = (eId - sId + 1);
      const tries = [
        `/api/ticks?start_id=${sId}&end_id=${eId}`,
        `/api/ticks?start=${sId}&limit=${n}`
      ];
      let lastErr;
      for(const u of tries){ try{ return await fetchJson(u); } catch(e){ lastErr = e; } }
      throw lastErr || new Error('ticks endpoint not found');
    }

    async function fetchLabels(kind, sId, eId){
      const tries = [
        `/api/${kind}?start_id=${sId}&end_id=${eId}`,
        `/api/${kind}?start=${sId}&end=${eId}`
      ];
      for(const u of tries){ try{ return await fetchJson(u); } catch(e){} }
      return [];
    }

    // ------------ RENDER ------------
    function priceLine(name, data, w=1){ return { name, type:'line', showSymbol:false, smooth:0, lineStyle:{width:w}, data }; }

    function pick(o, names){ for(const k of names){ if(o[k]!=null) return o[k]; } return null; }

    // build zigzag segments for maxi/medi/micro
    function buildZigzag(rows, name){
      const pts=[];
      for(const r of rows){
        const sid = pick(r, ['start_id','startId','sid','from_id','start_tick_id']);
        const eid = pick(r, ['end_id','endId','eid','to_id','end_tick_id']);
        let t1 = pick(r, ['start_ts','start_time']);
        let t2 = pick(r, ['end_ts','end_time']);
        let p1 = pick(r, ['start_price','price_start']);
        let p2 = pick(r, ['end_price','price_end']);

        if((!t1 || p1==null) && sid && tickMap.has(sid)){ const t=tickMap.get(sid); t1=t.ts; p1=(t.mid ?? t.price ?? t.bid ?? t.ask); }
        if((!t2 || p2==null) && eid && tickMap.has(eid)){ const t=tickMap.get(eid); t2=t.ts; p2=(t.mid ?? t.price ?? t.bid ?? t.ask); }

        if(t1 && t2 && p1!=null && p2!=null){ pts.push([t1,p1],[t2,p2],[null,null]); }
      }
      return {
        name, type:'line', connectNulls:false, showSymbol:true, symbolSize:4,
        lineStyle:{ width: name==='maxi'?2 : name==='medi'?1.5 : 1.2 }, emphasis:{disabled:true}, z:10, data:pts
      };
    }

    async function loadTicksRange(sId, eId, append=false){
      const rows = await fetchTicks(sId, eId);
      if(!append){ tickMap.clear(); midSeries=[]; bidSeries=[]; askSeries=[]; }
      for(const r of rows){
        const id  = pick(r,['id','tick_id','tickId','tickid']);
        const ts  = pick(r,['ts','time','timestamp']);
        const mid = pick(r,['mid','price']);
        const bid = pick(r,['bid']);
        const ask = pick(r,['ask','offer']);
        if(id!=null && ts!=null){ tickMap.set(id,{ts,mid,bid,ask,price:mid??bid??ask}); }
        if(ts!=null){ if(mid!=null) midSeries.push([ts,mid]); if(bid!=null) bidSeries.push([ts,bid]); if(ask!=null) askSeries.push([ts,ask]); }
      }
    }

    async function renderAll(){
      readControls(); setBusy(true);
      try{
        const sPad = Math.max(1, startId - PADDING);
        const ePad = endId + PADDING;

        await loadTicksRange(sPad, ePad, false);

        const series=[];
        if($('#layMid').checked && midSeries.length) series.push(priceLine('mid', midSeries, 1.4));
        if($('#layBid').checked && bidSeries.length) series.push(priceLine('bid', bidSeries, 1));
        if($('#layAsk').checked && askSeries.length) series.push(priceLine('ask', askSeries, 1));

        const wants = [['maxi','#layMaxi'],['medi','#layMedi'],['micro','#layMicro']].filter(([_,sel])=>$(sel).checked);
        const labelResults = await Promise.all(wants.map(([k])=>fetchLabels(k, sPad, ePad).then(rows=>[k,rows])));
        for(const [name,rows] of labelResults){ series.push(buildZigzag(rows||[], name)); }

        chart.setOption({ series }, { replaceMerge:['series'] });
      }catch(err){
        alert('Load failed: '+err.message);
        console.error(err);
      }finally{ setBusy(false); }
    }

    async function loadMoreRight(){
      readControls();
      const oldEnd=endId, moreStart=oldEnd+1;
      endId = oldEnd + chunkSize;
      setBusy(true);
      try{
        const sPad = Math.max(1, moreStart - PADDING);
        const ePad = endId + PADDING;

        await loadTicksRange(sPad, ePad, true);

        const series=[];
        if($('#layMid').checked) series.push(priceLine('mid', midSeries, 1.4));
        if($('#layBid').checked) series.push(priceLine('bid', bidSeries, 1));
        if($('#layAsk').checked) series.push(priceLine('ask', askSeries, 1));

        const wants = [['maxi','#layMaxi'],['medi','#layMedi'],['micro','#layMicro']].filter(([_,sel])=>$(sel).checked);
        const labelResults = await Promise.all(wants.map(([k])=>fetchLabels(k, sPad, ePad).then(rows=>[k,rows])));
        for(const [name,rows] of labelResults){ series.push(buildZigzag(rows||[], name)); }

        chart.setOption({ series }, { replaceMerge:['series'] });
      }catch(err){
        alert('Load failed: '+err.message);
        console.error(err);
      }finally{ setBusy(false); }
    }

    $('#btnLoad').addEventListener('click', renderAll);
    $('#btnMoreRight').addEventListener('click', loadMoreRight);
    ['#layMid','#layBid','#layAsk','#layMaxi','#layMedi','#layMicro'].forEach(id=>$(id).addEventListener('change', renderAll));

    renderAll();
  </script>
</body>
</html>
