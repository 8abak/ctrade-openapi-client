<!-- PATH: frontend/review.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Review</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root{
      --bg:#0f172a; --panel:#111827; --muted:#9ca3af; --text:#e5e7eb; --hl:#334155; --accent:#1f2937;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial}
    .bar{display:flex;gap:.75rem;align-items:center;padding:.6rem .9rem;border-bottom:1px solid var(--hl);background:var(--panel);position:sticky;top:0;z-index:10}
    .bar label{color:var(--muted)}
    .bar input[type=number]{width:120px;padding:.4rem .5rem;background:#0b1220;color:var(--text);border:1px solid var(--hl);border-radius:.4rem}
    .btn{background:var(--accent);color:var(--text);border:1px solid var(--hl);border-radius:.45rem;padding:.45rem .8rem;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .row{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;padding:.45rem .9rem;border-bottom:1px solid var(--hl);background:#0d1424}
    .group{display:flex;gap:.6rem;align-items:center;flex-wrap:wrap;padding:.25rem .5rem;border-radius:.4rem;background:rgba(255,255,255,.02)}
    #chart{height:calc(100vh - 128px);width:100vw}
    @media (max-width:720px){ #chart{height:calc(100vh - 150px)} }
    .tag{color:var(--muted);font-weight:600;margin-right:.25rem}
  </style>
</head>
<body>
  <div class="bar">
    <label for="startId">Start ID</label>
    <input id="startId" type="number" min="1" step="1" value="1"/>
    <label for="chunkSize">Chunk size</label>
    <input id="chunkSize" type="number" min="100" step="100" value="2000"/>
    <button id="btnLoad" class="btn">Load</button>
    <button id="btnMore" class="btn">Load more (right)</button>
    <span style="margin-left:auto;color:var(--muted)">Legend toggles below • Zoom: <b>Shift+wheel</b> • Pan: <b>wheel</b></span>
  </div>

  <div class="row" id="layerRow">
    <span class="tag">Layers:</span>
    <div class="group" id="baseLayers"></div>
    <div class="group" id="labelLayers"></div>
  </div>

  <div id="chart"></div>

<script>
(function(){
  const qs = s => document.querySelector(s);

  // ---- API wrappers (read-only endpoints already present in backend) ----
  const API = {
    lastId: async () => fetch('/ticks/lastid').then(r=>r.json()),
    ticksRange: async (fromId,toId)=>fetch(`/api/ticks?from_id=${fromId}&to_id=${toId}`).then(r=>r.json()),
    sql: async (q)=>fetch(`/api/sql?q=${encodeURIComponent(q)}`).then(r=>r.json()),
  };

  // ---- State ----
  let chart, option;
  let fromId=1, toId=1, chunk=2000;
  let ticks=[];                    // [{id, ts, mid, bid?, ask?}]
  let idToIndex=new Map(), idToMid=new Map();
  let hasBid=false, hasAsk=false;
  const ACTIVE=new Set(['mid']);   // visible series
  let labelTables=[];              // ['atr1','bigm',...]
  const labelData=new Map();       // table -> [{idx,y,raw}]

  // ---- UI elements ----
  const $start=qs('#startId'), $chunk=qs('#chunkSize'), $btnLoad=qs('#btnLoad'), $btnMore=qs('#btnMore');
  const $base=qs('#baseLayers'), $labels=qs('#labelLayers');

  // ---- Setup ----
  window.addEventListener('resize', ()=> chart && chart.resize());

  function makeToggle(id,label,checked=false){
    const wrap=document.createElement('label');
    wrap.style.display='inline-flex'; wrap.style.gap='.35rem'; wrap.style.alignItems='center';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.value=id; cb.checked=checked;
    cb.addEventListener('change', async ()=>{
      if(cb.checked){ ACTIVE.add(id); if(!labelData.has(id)) await loadLabelTable(id, fromId, toId); }
      else { ACTIVE.delete(id); }
      render();
    });
    const span=document.createElement('span'); span.textContent=label;
    wrap.append(cb, span);
    return wrap;
  }

  async function discoverLabelTables(){
    const q = `
      SELECT DISTINCT table_name
      FROM information_schema.columns
      WHERE table_schema='public' AND column_name='tickid'
      ORDER BY table_name
    `;
    const res = await API.sql(q);
    labelTables = (res.rows||[]).map(r=>r.table_name).filter(n=>n!=='ticks');
    // build toggles
    $labels.innerHTML='';
    for(const t of labelTables){
      const defaultOn=['atr1','bigm','smal','pred'].includes(t);
      const node=makeToggle(t,t,defaultOn);
      $labels.appendChild(node);
    }
  }

  function baseOption(){
    return {
      backgroundColor: getComputedStyle(document.body).backgroundColor,
      animation:false,
      grid:{left:64,right:24,top:68,bottom:42},
      legend:{top:8,textStyle:{color:'#d1d5db'}},
      tooltip:{
        trigger:'axis', axisPointer:{type:'cross'}, confine:true,
        formatter: params => tooltipHTML(params)
      },
      xAxis:{
        type:'category', data:[],
        axisLine:{lineStyle:{color:'#475569'}}, axisLabel:{color:'#cbd5e1'}
      },
      yAxis:{
        type:'value', scale:true,
        axisLine:{lineStyle:{color:'#475569'}},
        axisLabel:{color:'#cbd5e1', formatter:v=>Math.round(v)},
        splitLine:{lineStyle:{color:'#1f2937'}}
      },
      dataZoom:[
        // Inside: wheel pans; Shift+wheel zooms; drag to pan
        { type:'inside',
          zoomOnMouseWheel:'shift',
          moveOnMouseWheel:true,
          moveOnMouseMove:true,
          preventDefaultMouseMove:true
        },
        { type:'slider', bottom:8 }
      ],
      series:[]
    };
  }

  function tooltipHTML(params){
    if(!params || !params.length) return '';
    const i=params[0].dataIndex, t=ticks[i]; if(!t) return '';
    const dt=new Date(t.ts);
    const lines=[];
    lines.push(`<div><b>ID:</b> ${t.id} &nbsp; <b>Date:</b> ${dt.toLocaleDateString()} &nbsp; <b>Time:</b> ${dt.toLocaleTimeString()}</div>`);
    if(ACTIVE.has('mid')) lines.push(`<div>mid: <b>${t.mid}</b></div>`);
    if(ACTIVE.has('bid') && hasBid && t.bid!=null) lines.push(`<div>bid: <b>${t.bid}</b></div>`);
    if(ACTIVE.has('ask') && hasAsk && t.ask!=null) lines.push(`<div>ask: <b>${t.ask}</b></div>`);
    // attach label rows present at this tick via params inspection
    for(const p of params){
      if(p.seriesType!=='scatter') continue;
      const raw = Array.isArray(p.data) ? p.data[2] : null; if(!raw) continue;
      const obj={...raw}; delete obj.tickid;
      lines.push(`<div>${p.seriesName}: <code>${JSON.stringify(obj)}</code></div>`);
    }
    return lines.join('');
  }

  async function loadInitial(){
    try{
      const info=await API.lastId();
      const lastId=Number(info.lastId || info.lastid || 0);
      const c=Number($chunk.value||2000);
      $start.value=Math.max(1,lastId - c + 1);
    }catch(e){}
    await discoverLabelTables();
    // base toggles
    $base.innerHTML='';
    $base.appendChild(makeToggle('mid','mid',true));
    $base.appendChild(makeToggle('bid','bid',false));
    $base.appendChild(makeToggle('ask','ask',false));
    // chart
    chart=echarts.init(qs('#chart'));
    option=baseOption();
    chart.setOption(option);
    chart.on('dataZoom', adjustYAxisToView);
  }

  function buildTickState(prev, newly){
    ticks=(prev||[]).concat(newly||[]);
    idToIndex=new Map(); idToMid=new Map(); hasBid=false; hasAsk=false;
    ticks.forEach((r,i)=>{
      idToIndex.set(r.id,i); idToMid.set(r.id,r.mid);
      if(r.bid!=null) hasBid=true; if(r.ask!=null) hasAsk=true;
      if(typeof r.ts!=='string' && r.ts && r.ts.toISOString) r.ts=r.ts.toISOString();
    });
  }

  async function loadLabelTable(tbl, from, to){
    const q=`SELECT * FROM ${tbl} WHERE tickid BETWEEN ${from} AND ${to} ORDER BY tickid`;
    const res=await API.sql(q); const rows=res.rows||[];
    const pts=[];
    for(const r of rows){
      const idx=idToIndex.get(r.tickid), y=idToMid.get(r.tickid);
      if(idx!=null && y!=null) pts.push({idx,y,raw:r});
    }
    labelData.set(tbl, pts);
  }

  async function loadAllActiveLabels(from,to){
    // fetch for all active label tables (on-demand; no data if not toggled)
    const jobs=[];
    for(const tbl of labelTables){
      if(!ACTIVE.has(tbl)) continue;
      jobs.push(loadLabelTable(tbl, from, to));
    }
    await Promise.all(jobs);
  }

  async function doLoad(reset=true){
    fromId=Number($start.value||1);
    chunk =Number($chunk.value||2000);
    toId  =fromId + chunk - 1;

    const t=await API.ticksRange(fromId,toId);
    buildTickState(reset?[]:ticks, t);
    await loadAllActiveLabels(fromId,toId);
    render();
    adjustYAxisToView(); // ensure fit
  }

  async function doMore(){
    if(!chart || !ticks.length) return;

    // 1. capture current zoom window (as percentages + actual id range)
    const opt = chart.getOption();
    const dz   = (opt.dataZoom && opt.dataZoom[0]) || {};
    const startP = typeof dz.start === 'number' ? dz.start : 0;
    const endP   = typeof dz.end   === 'number' ? dz.end   : 100;
    const n = ticks.length;
    const startIdx = Math.max(0, Math.floor(startP/100*n));
    const endIdx   = Math.min(n-1, Math.ceil(endP/100*n));
    const zoomStartId = ticks[startIdx].id;
    const zoomEndId   = ticks[endIdx].id;

    // 2. fetch next chunk
    const nextFrom = toId+1, nextTo = toId+chunk;
    const t = await API.ticksRange(nextFrom, nextTo);
    buildTickState(ticks, t);
    await loadAllActiveLabels(nextFrom,nextTo);
    toId = nextTo;

    // 3. re-render
    render();

    // 4. restore zoom window (map back to new length using IDs)
    const newStartIdx = idToIndex.get(zoomStartId) || 0;
    const newEndIdx   = idToIndex.get(zoomEndId)   || ticks.length-1;
    const newStartP = (newStartIdx / ticks.length) * 100;
    const newEndP   = (newEndIdx   / ticks.length) * 100;

    chart.setOption({
      dataZoom: [
        { start: newStartP, end: newEndP },
        { start: newStartP, end: newEndP }
      ]
    });
  }


  function render(){
    if(!chart) return;
    option.xAxis.data = ticks.map(t=>String(t.id));

    const series=[];
    if(ACTIVE.has('mid')){
      series.push({name:'mid',type:'line',showSymbol:false,data:ticks.map(t=>t.mid)});
    }
    if(ACTIVE.has('bid') && hasBid){
      series.push({name:'bid',type:'line',showSymbol:false,data:ticks.map(t=>t.bid)});
    }
    if(ACTIVE.has('ask') && hasAsk){
      series.push({name:'ask',type:'line',showSymbol:false,data:ticks.map(t=>t.ask)});
    }
    // label markers
    for(const tbl of labelTables){
      if(!ACTIVE.has(tbl)) continue;
      const pts=labelData.get(tbl)||[];
      series.push({
        name:tbl, type:'scatter', symbolSize:7,
        data: pts.map(p=>[p.idx, p.y, p.raw])
      });
    }
    option.series=series;
    option.legend.data=series.map(s=>s.name);
    chart.setOption(option, true);
  }

  function adjustYAxisToView(){
    if(!ticks.length) return;
    const opt = chart.getOption();
    const dz   = (opt.dataZoom && opt.dataZoom[0]) || {};
    const startP = typeof dz.start === 'number' ? dz.start : 0;
    const endP   = typeof dz.end   === 'number' ? dz.end   : 100;
    const n=ticks.length;
    const startIdx=Math.max(0, Math.floor(startP/100*n));
    const endIdx  =Math.min(n-1, Math.ceil(endP/100*n));
    const slice=ticks.slice(startIdx,endIdx+1);

    const vals=[];
    if(ACTIVE.has('mid')) vals.push(...slice.map(t=>t.mid).filter(v=>v!=null));
    if(ACTIVE.has('bid') && hasBid) vals.push(...slice.map(t=>t.bid).filter(v=>v!=null));
    if(ACTIVE.has('ask') && hasAsk) vals.push(...slice.map(t=>t.ask).filter(v=>v!=null));

    if(!vals.length) return;
    const min=Math.min(...vals), max=Math.max(...vals);
    const pad=Math.max(0.5,(max-min)*0.05);
    chart.setOption({ yAxis:{ min:min-pad, max:max+pad }});
  }

  // ---- Buttons ----
  $btnLoad.addEventListener('click', ()=>doLoad(true));
  $btnMore.addEventListener('click', ()=>doMore());

  // ---- Boot ----
  loadInitial();
})();
</script>
</body>
</html>
