<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ML Review — Price-Action Segments</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root{--bg:#0f172a;--panel:#111827;--ink:#e5e7eb;--muted:#94a3b8}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .toolbar{display:flex;gap:.75rem;align-items:center;padding:.6rem .8rem;background:var(--panel);position:sticky;top:0;z-index:2}
    .toolbar input[type="number"]{width:120px;background:#0b1220;border:1px solid #22304a;border-radius:8px;color:var(--ink);padding:.35rem .5rem}
    .toolbar button{background:#1f2a44;border:1px solid #334155;color:var(--ink);padding:.45rem .7rem;border-radius:8px;cursor:pointer}
    .toolbar button:hover{border-color:#4b5563}
    .layers{display:flex;align-items:center;gap:.65rem}
    .layers label{display:inline-flex;align-items:center;gap:.3rem;color:var(--muted)}
    .legend{padding:.3rem .8rem;color:var(--muted)}
    #wrap{height:calc(100% - 92px);display:flex;flex-direction:column}
    #chart{flex:1 1 auto;min-height:380px}
    .note{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="toolbar">
    <div>
      <div class="note">Start ID</div>
      <input id="startId" type="number" value="1" step="1" />
    </div>
    <div>
      <div class="note">Chunk size</div>
      <input id="chunk" type="number" value="2000" step="100" />
    </div>
    <button id="btnLoad">Load</button>
    <button id="btnMoreRight">Load more (right)</button>
    <div class="layers">
      <span class="note">Layers:</span>
      <label><input id="layMid" type="checkbox" checked /> mid</label>
      <label><input id="layBid" type="checkbox" /> bid</label>
      <label><input id="layAsk" type="checkbox" /> ask</label>
      <label><input id="layMaxi" type="checkbox" /> maxi</label>
      <label><input id="layMedi" type="checkbox" /> medi</label>
      <label><input id="layMicro" type="checkbox" checked /> micro</label>
    </div>
  </div>

  <div class="legend">Legend toggles below • Zoom: <b>Shift + wheel</b> • Pan: <b>wheel</b></div>

  <div id="wrap"><div id="chart"></div></div>

  <script>
    // ---------------- Config ----------------
    // If needed, you can hardcode paths here (kept blank to use /api/*).
    const API_BASE = ""; // e.g. "/api"
    const route = (p) => `${API_BASE}${p}`;

    // ---------------- Utilities ----------------
    const $ = (s)=>document.querySelector(s);
    const pretty = (x)=> typeof x==='string' ? x : JSON.stringify(x, null, 2);
    function setBusy(on){ document.body.style.cursor = on ? 'progress' : 'default'; }
    function readControls(){ startId = +$('#startId').value; chunkSize = +$('#chunk').value; endId = startId + chunkSize - 1; }

    async function fetchTry(url, init){
      const r = await fetch(url, init);
      const text = await r.text();
      let body;
      try { body = text ? JSON.parse(text) : null; } catch { body = text; }
      if(!r.ok) { const msg = (body && (body.detail || body.message)) || r.statusText; throw new Error(`${r.status} : ${url}\n${pretty(body)||msg}`); }
      return body;
    }

    // Smart tick fetcher: tries multiple shapes until one succeeds.
    async function fetchTicksSmart(sId, eId, n){
      const tries = [
        route(`/api/ticks?start_id=${sId}&end_id=${eId}`),
        route(`/api/ticks?start=${sId}&end=${eId}`),
        route(`/api/ticks?start_id=${sId}&limit=${n}`),
        route(`/api/ticks?start=${sId}&limit=${n}`),
        route(`/api/ticks?offset=${sId}&limit=${n}`),
        route(`/api/ticks/range?start_id=${sId}&end_id=${eId}`),
        route(`/api/ticks/range?start=${sId}&end=${eId}`),
        route(`/api/ticks?from_id=${sId}&to_id=${eId}`),
        route(`/api/ticks?from=${sId}&to=${eId}`),
      ];
      let lastErr;
      for(const u of tries){
        try { return await fetchTry(u); } catch(e){ lastErr = e; }
      }
      throw lastErr || new Error("No ticks endpoint succeeded");
    }

    async function fetchLabelsSmart(kind, sId, eId){
      const tries = [
        route(`/api/${kind}?start_id=${sId}&end_id=${eId}`),
        route(`/api/${kind}?start=${sId}&end=${eId}`),
        route(`/api/${kind}/range?start_id=${sId}&end_id=${eId}`),
        route(`/api/${kind}/range?start=${sId}&end=${eId}`),
      ];
      for(const u of tries){
        try { return await fetchTry(u); } catch(e){ /* try next; labels can be empty */ }
      }
      return [];
    }

    // ---------------- State ----------------
    let startId = +$('#startId').value;
    let chunkSize = +$('#chunk').value;
    let endId = startId + chunkSize - 1;

    // tickId -> { ts, mid, bid, ask, price }
    const tickMap = new Map();
    let midSeries=[], bidSeries=[], askSeries=[];

    const chart = echarts.init(document.getElementById('chart'));
    chart.setOption({
      darkMode:true, animation:false,
      tooltip:{ trigger:'axis', axisPointer:{ type:'cross' } },
      grid:{ left:60, right:20, top:30, bottom:110 },
      dataZoom:[ {type:'inside', filterMode:'none'}, {type:'slider', bottom:60, height:32} ],
      xAxis:{ type:'time', axisLabel:{color:'#9ca3af'} },
      yAxis:{ type:'value', scale:true, axisLabel:{color:'#9ca3af'} },
      series:[]
    });

    function priceLine(name, data, width=1){ return { name, type:'line', showSymbol:false, smooth:0, lineStyle:{width}, data }; }

    // Convert label rows to zigzag segments (the requested change)
    function buildZigzagFromLabels(rows, name){
      const pts=[];
      for(const r of rows){
        let t1 = r.start_ts ?? r.start_time ?? null;
        let t2 = r.end_ts   ?? r.end_time   ?? null;
        let p1 = r.start_price ?? null;
        let p2 = r.end_price   ?? null;
        const sid = r.start_id ?? r.startId ?? r.sid ?? r.start_tick_id;
        const eid = r.end_id   ?? r.endId   ?? r.eid ?? r.end_tick_id;

        if((!t1 || p1==null) && sid && tickMap.has(sid)){ const t = tickMap.get(sid); t1=t.ts; p1=(t.mid ?? t.price ?? t.bid ?? t.ask); }
        if((!t2 || p2==null) && eid && tickMap.has(eid)){ const t = tickMap.get(eid); t2=t.ts; p2=(t.mid ?? t.price ?? t.bid ?? t.ask); }

        if(t1 && t2 && p1!=null && p2!=null){ pts.push([t1,p1],[t2,p2],[null,null]); }
      }
      return { name, type:'line', connectNulls:false, showSymbol:true, symbolSize:4,
               lineStyle:{ width: name==='maxi'?2 : name==='medi'?1.5 : 1.2 }, emphasis:{disabled:true}, z:10, data:pts };
    }

    async function loadTicksRange(sId, eId, n, append=false){
      const rows = await fetchTicksSmart(sId, eId, n);
      if(!append){ tickMap.clear(); midSeries=[]; bidSeries=[]; askSeries=[]; }
      for(const r of rows){
        const id  = r.id ?? r.tick_id ?? r.tickid ?? r.tickId;
        const ts  = r.ts ?? r.time ?? r.timestamp;
        const mid = r.mid ?? r.price ?? null;
        const bid = r.bid ?? null;
        const ask = r.ask ?? r.offer ?? null;
        if(id!=null && ts!=null){ tickMap.set(id, { ts, mid, bid, ask, price: mid ?? bid ?? ask }); }
        if(ts!=null){ if(mid!=null) midSeries.push([ts,mid]); if(bid!=null) bidSeries.push([ts,bid]); if(ask!=null) askSeries.push([ts,ask]); }
      }
    }

    async function renderAll(){
      readControls(); setBusy(true);
      try{
        await loadTicksRange(startId, endId, chunkSize, false);

        const series=[];
        if($('#layMid').checked && midSeries.length) series.push(priceLine('mid', midSeries, 1.4));
        if($('#layBid').checked && bidSeries.length) series.push(priceLine('bid', bidSeries, 1));
        if($('#layAsk').checked && askSeries.length) series.push(priceLine('ask', askSeries, 1));

        const wants = [['maxi','#layMaxi'],['medi','#layMedi'],['micro','#layMicro']].filter(([_,sel])=>$(sel).checked);
        const labelResults = await Promise.all(wants.map(([k])=>fetchLabelsSmart(k, startId, endId).then(rows=>[k,rows])));
        for(const [name,rows] of labelResults){ series.push(buildZigzagFromLabels(rows||[], name)); }

        chart.setOption({ series }, { replaceMerge:['series'] });
      }catch(err){
        alert('Load failed: '+err.message);
        console.error(err);
      }finally{ setBusy(false); }
    }

    async function loadMoreRight(){
      readControls();
      const oldEnd=endId, moreStart=oldEnd+1;
      endId = oldEnd + chunkSize;
      setBusy(true);
      try{
        await loadTicksRange(moreStart, endId, chunkSize, true);

        const series=[];
        if($('#layMid').checked) series.push(priceLine('mid', midSeries, 1.4));
        if($('#layBid').checked) series.push(priceLine('bid', bidSeries, 1));
        if($('#layAsk').checked) series.push(priceLine('ask', askSeries, 1));
        const wants = [['maxi','#layMaxi'],['medi','#layMedi'],['micro','#layMicro']].filter(([_,sel])=>$(sel).checked);
        const labelResults = await Promise.all(wants.map(([k])=>fetchLabelsSmart(k, startId, endId).then(rows=>[k,rows])));
        for(const [name,rows] of labelResults){ series.push(buildZigzagFromLabels(rows||[], name)); }

        chart.setOption({ series }, { replaceMerge:['series'] });
      }catch(err){
        alert('Load failed: '+err.message);
        console.error(err);
      }finally{ setBusy(false); }
    }

    $('#btnLoad').addEventListener('click', renderAll);
    $('#btnMoreRight').addEventListener('click', loadMoreRight);
    ['#layMid','#layBid','#layAsk','#layMaxi','#layMedi','#layMicro'].forEach(id=>$(id).addEventListener('change', renderAll));

    renderAll();
  </script>
</body>
</html>
