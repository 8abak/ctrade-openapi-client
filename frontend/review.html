<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ML Review — Price-Action Segments</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- ECharts -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root{--bg:#0f172a;--panel:#111827;--ink:#e5e7eb;--muted:#94a3b8;--accent:#60a5fa}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .toolbar{display:flex;gap:.75rem;align-items:center;padding:.6rem .8rem;background:var(--panel);position:sticky;top:0;z-index:2}
    .toolbar input[type="number"]{width:110px;background:#0b1220;border:1px solid #22304a;border-radius:8px;color:var(--ink);padding:.35rem .5rem}
    .toolbar button{background:#1f2a44;border:1px solid #334155;color:var(--ink);padding:.45rem .7rem;border-radius:8px;cursor:pointer}
    .toolbar button:hover{border-color:#4b5563}
    .layers{display:flex;align-items:center;gap:.65rem}
    .layers label{display:inline-flex;align-items:center;gap:.3rem;color:var(--muted)}
    .legend{padding:.3rem .8rem;color:var(--muted)}
    #wrap{height:calc(100% - 92px);display:flex;flex-direction:column}
    #chart{flex:1 1 auto;min-height:380px}
    .note{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="toolbar">
    <div>
      <div class="note">Start ID</div>
      <input id="startId" type="number" value="1" step="1" />
    </div>
    <div>
      <div class="note">Chunk size</div>
      <input id="chunk" type="number" value="2000" step="100" />
    </div>
    <button id="btnLoad">Load</button>
    <button id="btnMoreRight">Load more (right)</button>
    <div class="layers">
      <span class="note">Layers:</span>
      <label><input id="layMid" type="checkbox" checked /> mid</label>
      <label><input id="layBid" type="checkbox" /> bid</label>
      <label><input id="layAsk" type="checkbox" /> ask</label>
      <label><input id="layMaxi" type="checkbox" /> maxi</label>
      <label><input id="layMedi" type="checkbox" /> medi</label>
      <label><input id="layMicro" type="checkbox" checked /> micro</label>
    </div>
  </div>

  <div class="legend">Legend toggles below • Zoom: <b>Shift + wheel</b> • Pan: <b>wheel</b></div>

  <div id="wrap">
    <div id="chart"></div>
  </div>

  <script>
    // ---- Config ----
    const API = {
      ticks:  (s, e) => `/api/ticks?start=${s}&end=${e}`,
      maxi:   (s, e) => `/api/maxi?start=${s}&end=${e}`,
      medi:   (s, e) => `/api/medi?start=${s}&end=${e}`,
      micro:  (s, e) => `/api/micro?start=${s}&end=${e}`,
    };

    // ---- State ----
    let startId   = Number(document.getElementById('startId').value);
    let chunkSize = Number(document.getElementById('chunk').value);
    let endId     = startId + chunkSize - 1;

    // tickId → { ts, mid, bid, ask }
    const tickMap = new Map();
    let midSeries = []; // [ [ts, mid], ... ]
    let bidSeries = [];
    let askSeries = [];

    // ECharts setup
    const chart = echarts.init(document.getElementById('chart'));
    const baseOption = {
      darkMode: true,
      animation: false,
      tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
      grid: { left: 60, right: 20, top: 30, bottom: 110 },
      dataZoom: [
        { type: 'inside', filterMode: 'none' },
        { type: 'slider', bottom: 60, height: 32 },
      ],
      xAxis: { type: 'time', axisLabel:{color:'#9ca3af'} },
      yAxis: { type: 'value', scale: true, axisLabel:{color:'#9ca3af'} },
      series: []
    };
    chart.setOption(baseOption);

    // Helpers
    const $ = sel => document.querySelector(sel);
    function setBusy(on) { document.body.style.cursor = on ? 'progress' : 'default'; }

    function readControls() {
      startId   = Number($('#startId').value);
      chunkSize = Number($('#chunk').value);
      endId     = startId + chunkSize - 1;
    }

    async function fetchJson(url) {
      const r = await fetch(url);
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}: ${url}`);
      return r.json();
    }

    // Build zigzag series points by concatenating small 2-point segments separated with nulls.
    // Accepts label items with either (start_id,end_id) or (start_ts,end_ts).
    // If we only have IDs, look up ts/price from tickMap.
    function buildZigzagFromLabels(labelRows, color, name) {
      const pts = [];
      for (const row of labelRows) {
        // Try explicit timestamps first
        let t1 = row.start_ts ?? row.start_time ?? null;
        let t2 = row.end_ts   ?? row.end_time   ?? null;
        let p1 = row.start_price ?? null;
        let p2 = row.end_price   ?? null;

        // If we have ids, derive from tickMap (mid price)
        if ((!t1 || p1 == null) && row.start_id && tickMap.has(row.start_id)) {
          const t = tickMap.get(row.start_id);
          t1 = t.ts;
          p1 = (t.mid ?? t.price ?? t.bid ?? t.ask);
        }
        if ((!t2 || p2 == null) && row.end_id && tickMap.has(row.end_id)) {
          const t = tickMap.get(row.end_id);
          t2 = t.ts;
          p2 = (t.mid ?? t.price ?? t.bid ?? t.ask);
        }

        if (t1 && t2 && p1 != null && p2 != null) {
          pts.push([t1, p1], [t2, p2], [null, null]); // null breaks the line (separate segments)
        }
      }
      return {
        name,
        type: 'line',
        connectNulls: false,
        showSymbol: true,
        symbolSize: 4,
        lineStyle: { width: name==='maxi'?2 : name==='medi'?1.5:1.2 },
        emphasis: { disabled: true },
        data: pts
      };
    }

    function priceLine(name, data, width=1) {
      return {
        name, type:'line', showSymbol:false, smooth:0, lineStyle:{width},
        data
      };
    }

    async function loadTicksRange(s, e, append=false) {
      const rows = await fetchJson(API.ticks(s, e));
      if (!append) {
        tickMap.clear();
        midSeries = []; bidSeries = []; askSeries = [];
      }
      for (const r of rows) {
        // Accept any of: id, ts/time, mid, bid, ask, price
        const id  = r.id ?? r.tick_id ?? r.tickid ?? r.tickId;
        const ts  = r.ts ?? r.time ?? r.timestamp;
        const mid = r.mid ?? r.price ?? null;
        const bid = r.bid ?? null;
        const ask = r.ask ?? r.offer ?? null;
        if (id != null && ts != null) {
          tickMap.set(id, { ts, mid, bid, ask, price: mid ?? bid ?? ask });
        }
        if (ts != null) {
          if (mid != null) midSeries.push([ts, mid]);
          if (bid != null) bidSeries.push([ts, bid]);
          if (ask != null) askSeries.push([ts, ask]);
        }
      }
    }

    async function renderAll() {
      readControls();
      setBusy(true);

      // --- ticks
      await loadTicksRange(startId, endId, /*append*/false);
      const series = [];
      if ($('#layMid').checked && midSeries.length) series.push(priceLine('mid', midSeries, 1.4));
      if ($('#layBid').checked && bidSeries.length) series.push(priceLine('bid', bidSeries, 1));
      if ($('#layAsk').checked && askSeries.length) series.push(priceLine('ask', askSeries, 1));

      // --- labels AS ZIGZAG (this is the only behavioral change)
      const wantMaxi = $('#layMaxi').checked;
      const wantMedi = $('#layMedi').checked;
      const wantMicro= $('#layMicro').checked;

      // fetch in parallel if any requested
      const jobs = [];
      if (wantMaxi) jobs.push(fetchJson(API.maxi(startId, endId)).then(rows => ['maxi', rows]));
      if (wantMedi) jobs.push(fetchJson(API.medi(startId, endId)).then(rows => ['medi', rows]));
      if (wantMicro)jobs.push(fetchJson(API.micro(startId, endId)).then(rows => ['micro',rows]));

      const results = await Promise.allSettled(jobs);
      for (const r of results) {
        if (r.status !== 'fulfilled') continue;
        const [name, rows] = r.value;
        // choose a distinct width; color is theme-driven (we won't hardcode colors)
        const zig = buildZigzagFromLabels(rows || [], null, name);
        // Slight z-order: draw on top of price
        zig.z = 10;
        series.push(zig);
      }

      chart.setOption({ series }, { replaceMerge: ['series'] });
      setBusy(false);
    }

    async function loadMoreRight() {
      readControls();
      const oldEnd = endId;
      const moreStart = oldEnd + 1;
      endId = oldEnd + chunkSize;
      setBusy(true);
      await loadTicksRange(moreStart, endId, /*append*/true);

      const existing = chart.getOption().series || [];
      const merged = [];

      // Update price lines
      const midIdx = existing.findIndex(s => s.name === 'mid');
      const bidIdx = existing.findIndex(s => s.name === 'bid');
      const askIdx = existing.findIndex(s => s.name === 'ask');
      if ($('#layMid').checked) {
        const s = priceLine('mid', midSeries, 1.4); s.z = 1;
        if (midIdx >= 0) existing[midIdx] = s; else existing.push(s);
      }
      if ($('#layBid').checked) {
        const s = priceLine('bid', bidSeries, 1); s.z = 1;
        if (bidIdx >= 0) existing[bidIdx] = s; else existing.push(s);
      }
      if ($('#layAsk').checked) {
        const s = priceLine('ask', askSeries, 1); s.z = 1;
        if (askIdx >= 0) existing[askIdx] = s; else existing.push(s);
      }

      // Re-fetch labels for the new tail, then rebuild zigzags covering the whole viewport
      const wantMaxi = $('#layMaxi').checked;
      const wantMedi = $('#layMedi').checked;
      const wantMicro= $('#layMicro').checked;

      const jobs = [];
      if (wantMaxi) jobs.push(fetchJson(API.maxi(startId, endId)).then(rows => ['maxi', rows]));
      if (wantMedi) jobs.push(fetchJson(API.medi(startId, endId)).then(rows => ['medi', rows]));
      if (wantMicro)jobs.push(fetchJson(API.micro(startId, endId)).then(rows => ['micro',rows]));
      const results = await Promise.allSettled(jobs);

      // Remove any prior label series
      const filtered = existing.filter(s => !['maxi','medi','micro'].includes(s.name));
      for (const r of results) {
        if (r.status !== 'fulfilled') continue;
        const [name, rows] = r.value;
        const zig = buildZigzagFromLabels(rows || [], null, name);
        zig.z = 10;
        filtered.push(zig);
      }

      chart.setOption({ series: filtered }, { replaceMerge: ['series'] });
      setBusy(false);
    }

    // Events
    $('#btnLoad').addEventListener('click', renderAll);
    $('#btnMoreRight').addEventListener('click', loadMoreRight);
    ['#layMid','#layBid','#layAsk','#layMaxi','#layMedi','#layMicro'].forEach(id=>{
      $(id).addEventListener('change', renderAll);
    });

    // Initial render
    renderAll().catch(err => {
      console.error(err);
      setBusy(false);
      alert('Load failed: ' + err.message);
    });
  </script>
</body>
</html>
