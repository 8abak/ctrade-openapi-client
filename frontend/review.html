<!-- PATH: frontend/review.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Review</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- ECharts (no custom colors/styles specified) -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root {
      --bg: #0f172a;           /* slate-900 */
      --panel: #111827;        /* gray-900 */
      --muted: #9ca3af;        /* gray-400 */
      --text: #e5e7eb;         /* gray-200 */
      --accent: #1f2937;       /* gray-800 */
      --hl: #334155;           /* slate-700 */
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    .bar {
      display: flex;
      align-items: center;
      gap: .75rem;
      padding: .6rem .9rem;
      border-bottom: 1px solid var(--hl);
      background: var(--panel);
      position: sticky; top: 0; z-index: 10;
    }
    .bar label { color: var(--muted); }
    .bar input[type="number"]{
      width: 120px; padding: .4rem .5rem; background: #0b1220; color: var(--text);
      border: 1px solid var(--hl); border-radius: .4rem;
    }
    .btn {
      background: var(--accent); color: var(--text);
      border: 1px solid var(--hl); border-radius: .45rem;
      padding: .45rem .8rem; cursor: pointer;
    }
    .btn:active { transform: translateY(1px); }
    .row {
      display: flex; gap: .75rem; align-items: center; flex-wrap: wrap;
      padding: .45rem .9rem; border-bottom: 1px solid var(--hl); background: #0d1424;
    }
    .row .group {
      display: flex; align-items: center; gap: .5rem; flex-wrap: wrap;
      padding: .25rem .5rem; border-radius: .4rem; background: rgba(255,255,255,0.02);
    }
    .row input[type="checkbox"] { transform: translateY(1px); }
    #chart {
      height: calc(100vh - 128px); /* header (~54px) + layer row (~54px) + margin */
      width: 100vw; 
    }
    @media (max-width: 720px){ #chart { height: calc(100vh - 150px); } }
    .tag { color: var(--muted); font-weight: 600; margin-right: .25rem; }
  </style>
</head>
<body>
  <!-- Top controls -->
  <div class="bar">
    <label for="startId">Start&nbsp;ID</label>
    <input id="startId" type="number" min="1" step="1" value="1" />
    <label for="chunkSize">Chunk&nbsp;size</label>
    <input id="chunkSize" type="number" min="100" step="100" value="2000" />
    <button id="btnLoad" class="btn">Load</button>
    <button id="btnMore" class="btn">Load more (right)</button>
    <span style="margin-left:auto;color:var(--muted)">Legend toggles below • Zoom: mousewheel / drag • Pan: shift+wheel</span>
  </div>

  <!-- Dynamic layer toggles -->
  <div class="row" id="layerRow">
    <span class="tag">Layers:</span>
    <div class="group" id="baseLayers"></div>
    <div class="group" id="labelLayers"></div>
  </div>

  <!-- Chart -->
  <div id="chart"></div>

<script>
(function(){
  // ---------- Helpers ----------
  const qs  = sel => document.querySelector(sel);
  const qsa = sel => Array.from(document.querySelectorAll(sel));
  const API = {
    lastId: async () => fetch('/ticks/lastid').then(r=>r.json()),
    ticksRange: async (fromId, toId) => fetch(`/api/ticks?from_id=${fromId}&to_id=${toId}`).then(r=>r.json()),
    tables: async () => fetch('/api/sql/tables').then(r=>r.json()),
    sql: async (q) => fetch(`/api/sql?q=${encodeURIComponent(q)}`).then(r=>r.json()),
  };

  // ---------- State ----------
  let chart, option;
  let fromId = 1, toId = 1, chunk = 2000;
  let ticks = [];                  // [{id, ts, mid, bid?, ask?}]
  let idToIndex = new Map();       // tickid -> index in ticks[]
  let idToMid = new Map();         // tickid -> mid
  let hasBid = false, hasAsk = false;
  let labelTables = [];            // discovered tables having 'tickid' column
  const ACTIVE = new Set(['mid']); // which series to show

  // ---------- UI wiring ----------
  const $start   = qs('#startId');
  const $chunk   = qs('#chunkSize');
  const $btnLoad = qs('#btnLoad');
  const $btnMore = qs('#btnMore');
  const $base    = qs('#baseLayers');
  const $labels  = qs('#labelLayers');

  window.addEventListener('resize', () => { if(chart) chart.resize(); });

  // Create checkbox helper
  function makeToggle(id, label, checked=false){
    const wrap = document.createElement('label');
    wrap.style.display='inline-flex'; wrap.style.alignItems='center'; wrap.style.gap='.35rem';
    const cb = document.createElement('input');
    cb.type='checkbox'; cb.value=id; cb.checked = checked;
    cb.addEventListener('change', async ()=>{
      if(cb.checked){
        ACTIVE.add(id);
        await loadLabelTable(id, fromId, toId);
      } else {
        ACTIVE.delete(id);
      }
      render();
    });
    const span = document.createElement('span'); span.textContent = label;
    wrap.append(cb, span);
    return wrap;
  }

  // ---------- Discovery of label tables (has column "tickid") ----------
  async function discoverLabelTables(){
    // One SELECT to get all such tables
    const q = `
      SELECT DISTINCT table_name
      FROM information_schema.columns
      WHERE table_schema='public'
        AND column_name='tickid'
      ORDER BY table_name
    `;
    const data = await API.sql(q);
    labelTables = (data.rows || []).map(r => r.table_name).filter(n => n !== 'ticks');
    // Build toggles
    $labels.innerHTML = '';
    for(const t of labelTables){
      // Default ON for common ones, OFF otherwise
      const defaultOn = ['atr1','bigm','smal','pred'].includes(t);
      if(defaultOn) ACTIVE.add(t);
      $labels.appendChild(makeToggle(t, t, defaultOn));
    }
  }

  // ---------- Load orchestration ----------
  async function loadInitial(){
    // sensible defaults: set start to (lastId - chunk + 1)
    try{
      const info = await API.lastId(); // { lastId, timestamp }
      const lastId = Number(info.lastId || info.lastid || 0);
      const chosenChunk = Number($chunk.value || 2000);
      const s = Math.max(1, lastId - chosenChunk + 1);
      $start.value = s;
    }catch(e){ /* ignore */ }
    await discoverLabelTables();
    // recalculate min/max
    $labels.innerHTML = '';
    for(const t of labelTables){
      const defaultOn = ['atr1','bigm','smal','pred'].includes(t);
      const cb = makeToggle(t, t, defaultOn);
      $labels.appendChild(cb);
      if(defaultOn) loadLabelTable(t, fromId, toId); // preload defaults
    }
    // Setup base toggles
    $base.innerHTML = '';
    $base.appendChild(makeToggle('mid', 'mid', true));
    $base.appendChild(makeToggle('bid', 'bid', false));
    $base.appendChild(makeToggle('ask', 'ask', false));
    // Init chart
    chart = echarts.init(qs('#chart'));
    option = baseOption();
    chart.setOption(option);
  }

  function baseOption(){
    return {
      backgroundColor: getComputedStyle(document.body).backgroundColor,
      animation: false,
      grid: { left: 64, right: 24, top: 68, bottom: 42 },
      legend: { top: 8, textStyle: { color: '#d1d5db' } },
      tooltip: {
        trigger: 'axis',
        axisPointer: { type: 'cross' },
        confine: true,
        formatter: params => tooltipHTML(params)
      },
      xAxis: {
        type: 'category',
        data: [],
        axisLine: { lineStyle:{ color:'#475569' } },
        axisLabel: { color:'#cbd5e1' }
      },
      yAxis: {
        type: 'value',
        scale: true,
        axisLine: { lineStyle:{ color:'#475569' } },
        axisLabel: {
          color:'#cbd5e1',
          formatter: v => Math.round(v)  // integers on axis
        },
        splitLine: { lineStyle: { color: '#1f2937' } }
      },
      dataZoom: [
        { type:'inside' }, // wheel/pinch
        { type:'slider', bottom: 8 }
      ],
      series: []
    };
  }

  async function doLoad(reset=true){
    fromId = Number($start.value || 1);
    chunk  = Number($chunk.value || 2000);
    toId   = fromId + chunk - 1;

    const t = await API.ticksRange(fromId, toId);
    buildTickState(reset ? [] : ticks, t);
    await loadAllLabels(fromId, toId); // overlays
    render();
  }

  async function doMore(){
    const nextFrom = toId + 1;
    const nextTo   = toId + chunk;
    const t = await API.ticksRange(nextFrom, nextTo);
    buildTickState(ticks, t); // append
    await loadAllLabels(nextFrom, nextTo);
    toId = nextTo;
    render();
  }

  async function loadLabelTable(tbl, from, to){
    const q = `SELECT * FROM ${tbl} WHERE tickid BETWEEN ${from} AND ${to} ORDER BY tickid`;
    const res = await API.sql(q);
    const rows = res.rows || [];
    const pts = [];
    for(const r of rows){
      const idx = idToIndex.get(r.tickid);
      const y   = idToMid.get(r.tickid);
      if(idx!=null && y!=null) pts.push({ idx,y,raw:r });
    }
    labelData.set(tbl, pts);
  }


  function buildTickState(prev, newly){
    // Keep order ascending by id, no thinning
    ticks = (prev || []).concat(newly || []);
    idToIndex = new Map();
    idToMid   = new Map();
    hasBid = false; hasAsk = false;
    ticks.forEach((r, i) => {
      idToIndex.set(r.id, i);
      idToMid.set(r.id, r.mid);
      if (r.bid != null) hasBid = true;
      if (r.ask != null) hasAsk = true;
      // normalize ts to ISO string for tooltips
      if (typeof r.ts === 'string') { /* ok */ }
      else if (r.ts && r.ts.toISOString) r.ts = r.ts.toISOString();
    });
  }

  // ---------- Labels fetch & shaping ----------
  const labelData = new Map(); // table -> array of {idx,y,raw}

  async function loadAllLabels(fromId, toId){
    for(const tbl of labelTables){
      if(!ACTIVE.has(tbl)) continue; // only fetch for active to reduce load
      const q = `SELECT * FROM ${tbl} WHERE tickid BETWEEN ${fromId} AND ${toId} ORDER BY tickid`;
      const res = await API.sql(q);
      const rows = (res.rows || []);
      const pts = [];
      for(const r of rows){
        const idx = idToIndex.get(r.tickid);
        if(idx == null) continue;              // skip if outside loaded ticks
        const y = idToMid.get(r.tickid);       // plot at current mid to show presence
        if(y == null) continue;
        pts.push({ idx, y, raw: r });
      }
      labelData.set(tbl, pts);
    }
  }

  // ---------- Rendering ----------
  function render(){
    if(!chart) return;
    option.xAxis.data = ticks.map(t => String(t.id));

    // Compute Y range from the tick lines actually shown
    const mids = ticks.map(t => t.mid).filter(v=>v!=null);
    const bids = (ACTIVE.has('bid') && hasBid) ? ticks.map(t=>t.bid).filter(v=>v!=null) : [];
    const asks = (ACTIVE.has('ask') && hasAsk) ? ticks.map(t=>t.ask).filter(v=>v!=null) : [];
    const merged = mids.concat(bids, asks);
    const yMin = merged.length ? Math.min(...merged) : 0;
    const yMax = merged.length ? Math.max(...merged) : 1;
    const pad  = Math.max(0.5, (yMax - yMin) * 0.05);
    option.yAxis.min = yMin - pad;
    option.yAxis.max = yMax + pad;

    // Build series list fresh each time (based on toggles)
    const series = [];
    if(ACTIVE.has('mid')){
      series.push({
        name: 'mid', type:'line', showSymbol:false,
        data: ticks.map(t=>t.mid)
      });
    }
    if(ACTIVE.has('bid') && hasBid){
      series.push({
        name: 'bid', type:'line', showSymbol:false,
        data: ticks.map(t=>t.bid)
      });
    }
    if(ACTIVE.has('ask') && hasAsk){
      series.push({
        name: 'ask', type:'line', showSymbol:false,
        data: ticks.map(t=>t.ask)
      });
    }

    // Label tables as scatter dots pinned to mid (presence indicators)
    for(const tbl of labelTables){
      if(!ACTIVE.has(tbl)) continue;
      const pts = labelData.get(tbl) || [];
      series.push({
        name: tbl,
        type: 'scatter',
        symbolSize: 7,
        encode: { x: 0, y: 1 },
        data: pts.map(p => [p.idx, p.y, p.raw]) // stash raw in data[2] for tooltip
      });
    }

    option.series = series;
    option.legend.data = series.map(s => s.name);
    chart.setOption(option, true);
  }

  function tooltipHTML(params){
    // params is an array of series at the hovered x-index
    if(!params || !params.length) return '';
    const i = params[0].dataIndex;
    const t = ticks[i];
    if(!t) return '';
    const dt = new Date(t.ts);
    const head =
      `<div><b>ID:</b> ${t.id} &nbsp; <b>Date:</b> ${dt.toLocaleDateString()} &nbsp; <b>Time:</b> ${dt.toLocaleTimeString()}</div>`;
    const core = [];
    if(ACTIVE.has('mid')) core.push(`<div>mid: <b>${t.mid}</b></div>`);
    if(ACTIVE.has('bid') && hasBid && t.bid!=null) core.push(`<div>bid: <b>${t.bid}</b></div>`);
    if(ACTIVE.has('ask') && hasAsk && t.ask!=null) core.push(`<div>ask: <b>${t.ask}</b></div>`);

    // Any label series at this index?
    const extras = [];
    for(const p of params){
      if(p.seriesType !== 'scatter') continue;
      const raw = (Array.isArray(p.data) ? p.data[2] : null);
      if(!raw) continue;
      // Pretty-print a compact JSON of the row (minus tickid if present)
      const obj = { ...raw }; delete obj.tickid;
      const json = JSON.stringify(obj);
      extras.push(`<div>${p.seriesName}: <code>${json}</code></div>`);
    }
    return [head].concat(core).concat(extras).join('');
  }

  // ---------- Buttons ----------
  $btnLoad.addEventListener('click', ()=> doLoad(true));
  $btnMore.addEventListener('click', ()=> doMore());

  // ---------- Bootstrap ----------
  loadInitial();
})();
</script>
</body>
</html>
