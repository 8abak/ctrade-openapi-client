<!-- PATH: frontend/review.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Review</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root{--bg:#0f172a;--panel:#111827;--muted:#9ca3af;--text:#e5e7eb;--hl:#334155;--accent:#1f2937}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial}
    .bar{display:flex;gap:.75rem;align-items:center;padding:.6rem .9rem;border-bottom:1px solid var(--hl);background:var(--panel);position:sticky;top:0;z-index:10}
    .bar label{color:var(--muted)}
    .bar input[type=number]{width:120px;padding:.4rem .5rem;background:#0b1220;color:var(--text);border:1px solid var(--hl);border-radius:.4rem}
    .btn{background:var(--accent);color:var(--text);border:1px solid var(--hl);border-radius:.45rem;padding:.45rem .8rem;cursor:pointer}
    .btn:active{transform:translateY(1px)}
    .row{display:flex;gap:.75rem;align-items:center;flex-wrap:wrap;padding:.45rem .9rem;border-bottom:1px solid var(--hl);background:#0d1424}
    .group{display:flex;gap:.6rem;align-items:center;flex-wrap:wrap;padding:.25rem .5rem;border-radius:.4rem;background:rgba(255,255,255,.02)}
    .tag{color:var(--muted);font-weight:600;margin-right:.25rem}
    #chart{height:calc(100vh - 128px);width:100vw}
    @media (max-width:720px){ #chart{height:calc(100vh - 150px)} }
  </style>
</head>
<body>
  <div class="bar">
    <label for="startId">Start ID</label>
    <input id="startId" type="number" min="1" step="1" value="1"/>
    <label for="chunkSize">Chunk size</label>
    <input id="chunkSize" type="number" min="100" step="100" value="2000"/>
    <button id="btnLoad" class="btn">Load</button>
    <button id="btnMore" class="btn">Load more (right)</button>
    <span style="margin-left:auto;color:var(--muted)">Legend toggles below • Zoom: <b>Shift+wheel</b> • Pan: <b>wheel</b></span>
  </div>

  <div class="row">
    <span class="tag">Layers:</span>
    <div class="group" id="baseLayers"></div>
    <div class="group" id="labelLayers"></div>
  </div>

  <div id="chart"></div>

<script>
(function(){
  // ---------- Shortcuts ----------
  const qs = s => document.querySelector(s);

  // ---------- Backend APIs (read-only) ----------
  const API = {
    lastId: () => fetch('/ticks/lastid').then(r=>r.json()),
    ticksRange: (a,b) => fetch(`/api/ticks?from_id=${a}&to_id=${b}`).then(r=>r.json()),
    sql: q => fetch(`/api/sql?q=${encodeURIComponent(q)}`).then(r=>r.json()),
  };

  // ---------- State ----------
  let chart, option;
  let fromId=1, toId=1, chunk=2000;
  let ticks=[]; // [{id, ts, mid, bid?, ask?}]
  let idToIndex=new Map(), idToMid=new Map();
  let hasBid=false, hasAsk=false;

  const ACTIVE=new Set(['mid']);    // visible series
  let labelTables=[];                // discovered tables
  const labelData=new Map();         // table -> [{idx,y,raw}]

  // ---------- UI ----------
  const $start=qs('#startId'), $chunk=qs('#chunkSize');
  qs('#btnLoad').addEventListener('click', ()=>doLoad(true));
  qs('#btnMore').addEventListener('click', ()=>doMore());

  // ---------- Helpers: zoom capture/restore ----------
  function getZoomPercents(){
    const opt=chart.getOption(); const dz=(opt.dataZoom && opt.dataZoom[0])||{};
    const startP = typeof dz.start === 'number' ? dz.start : 0;
    const endP   = typeof dz.end   === 'number' ? dz.end   : 100;
    return {startP, endP};
  }
  function getZoomIds(){
    if(!ticks.length) return {startId:null,endId:null};
    const {startP,endP}=getZoomPercents();
    const n=ticks.length;
    const sIdx=Math.max(0, Math.floor(startP/100*n));
    const eIdx=Math.min(n-1, Math.ceil(endP/100*n));
    return { startId: ticks[sIdx].id, endId: ticks[eIdx].id };
  }
  function restoreZoomByIds(startId,endId){
    if(startId==null || endId==null) return;
    const sIdx = idToIndex.get(startId) ?? 0;
    const eIdx = idToIndex.get(endId)   ?? (ticks.length-1);
    const sP = (sIdx / ticks.length) * 100;
    const eP = (eIdx / ticks.length) * 100;
    chart.setOption({ dataZoom:[{start:sP,end:eP},{start:sP,end:eP}] });
  }

  // ---------- Discovery ----------
  async function discoverLabelTables(){
    const q=`
      SELECT DISTINCT table_name
      FROM information_schema.columns
      WHERE table_schema='public' AND column_name='tickid'
      ORDER BY table_name
    `;
    const res=await API.sql(q);
    labelTables=(res.rows||[]).map(r=>r.table_name).filter(n=>n!=='ticks');

    const $labels=qs('#labelLayers'); $labels.innerHTML='';
    for(const t of labelTables){
      const defaultOn=['atr1','bigm','smal','pred'].includes(t);
      const cb=makeToggle(t,t,defaultOn,true); // true => label-table mode
      $labels.appendChild(cb);
      if(defaultOn) ACTIVE.add(t);
    }
  }

  // ---------- UI toggles ----------
  function makeToggle(id,label,checked=false,isLabel=false){
    const wrap=document.createElement('label');
    wrap.style.display='inline-flex'; wrap.style.gap='.35rem'; wrap.style.alignItems='center';
    const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=checked; cb.value=id;
    const span=document.createElement('span'); span.textContent=label;
    wrap.append(cb,span);

    cb.addEventListener('change', async ()=>{
      // preserve current zoom (by IDs) and Y-range
      const {startId,endId}=getZoomIds();
      const currentYAxis = chart.getOption().yAxis?.[0] || {};

      if(cb.checked){
        ACTIVE.add(id);
        if(isLabel){
          // fetch this label table for the currently loaded ID range
          await loadLabelTable(id, fromId, toId);
        }
      }else{
        ACTIVE.delete(id);
      }

      // update series only, keep zoom and y as-is
      render({preserveZoomIds:{startId,endId}, preserveYAxis: currentYAxis});
    });

    return wrap;
  }

  // ---------- Initial page setup ----------
  async function loadInitial(){
    try{
      const info=await API.lastId();
      const last=Number(info.lastId||info.lastid||0);
      const c = Number($chunk.value||2000);
      $start.value=Math.max(1, last - c + 1);
    }catch(e){}
    // Build base toggles
    const $base=qs('#baseLayers'); $base.innerHTML='';
    $base.appendChild(makeToggle('mid','mid',true,false));
    $base.appendChild(makeToggle('bid','bid',false,false));
    $base.appendChild(makeToggle('ask','ask',false,false));

    await discoverLabelTables();

    // Chart
    chart=echarts.init(qs('#chart'));
    option=baseOption(); chart.setOption(option);
    chart.on('dataZoom', adjustYAxisToView);
  }

  function baseOption(){
    return {
      backgroundColor: getComputedStyle(document.body).backgroundColor,
      animation:false,
      grid:{left:64,right:24,top:68,bottom:42},
      legend:{top:8,textStyle:{color:'#d1d5db'}},
      tooltip:{trigger:'axis',axisPointer:{type:'cross'},confine:true,formatter:tooltipHTML},
      xAxis:{type:'category',data:[],axisLine:{lineStyle:{color:'#475569'}},axisLabel:{color:'#cbd5e1'}},
      yAxis:{type:'value',scale:true,axisLine:{lineStyle:{color:'#475569'}},
             axisLabel:{color:'#cbd5e1',formatter:v=>Math.round(v)},splitLine:{lineStyle:{color:'#1f2937'}}},
      dataZoom:[
        { type:'inside', zoomOnMouseWheel:'shift', moveOnMouseWheel:true, moveOnMouseMove:true, preventDefaultMouseMove:true },
        { type:'slider', bottom:8 }
      ],
      series:[]
    };
  }

  function tooltipHTML(params){
    if(!params || !params.length) return '';
    const i=params[0].dataIndex; const t=ticks[i]; if(!t) return '';
    const dt=new Date(t.ts);
    const parts=[
      `<div><b>ID:</b> ${t.id} &nbsp; <b>Date:</b> ${dt.toLocaleDateString()} &nbsp; <b>Time:</b> ${dt.toLocaleTimeString()}</div>`
    ];
    if(ACTIVE.has('mid')) parts.push(`<div>mid: <b>${t.mid}</b></div>`);
    if(ACTIVE.has('bid') && hasBid && t.bid!=null) parts.push(`<div>bid: <b>${t.bid}</b></div>`);
    if(ACTIVE.has('ask') && hasAsk && t.ask!=null) parts.push(`<div>ask: <b>${t.ask}</b></div>`);
    for(const p of params){
      if(p.seriesType!=='scatter') continue;
      const raw=Array.isArray(p.data)?p.data[2]:null; if(!raw) continue;
      const obj={...raw}; delete obj.tickid;
      parts.push(`<div>${p.seriesName}: <code>${JSON.stringify(obj)}</code></div>`);
    }
    return parts.join('');
  }

  // ---------- Data building ----------
  function buildTickState(prev, newly){
    ticks=(prev||[]).concat(newly||[]);
    idToIndex=new Map(); idToMid=new Map(); hasBid=false; hasAsk=false;
    ticks.forEach((r,i)=>{
      idToIndex.set(r.id,i); idToMid.set(r.id,r.mid);
      if(r.bid!=null) hasBid=true; if(r.ask!=null) hasAsk=true;
      if(typeof r.ts!=='string' && r.ts && r.ts.toISOString) r.ts=r.ts.toISOString();
    });
  }

  async function loadLabelTable(tbl, a, b){
    const q=`SELECT * FROM ${tbl} WHERE tickid BETWEEN ${a} AND ${b} ORDER BY tickid`;
    const res=await API.sql(q); const rows=res.rows||[];
    const pts=[];
    for(const r of rows){
      const idx=idToIndex.get(r.tickid), y=idToMid.get(r.tickid);
      if(idx!=null && y!=null) pts.push({idx,y,raw:r});
    }
    labelData.set(tbl, pts);
  }

  async function loadAllActiveLabels(a,b){
    const jobs=[];
    for(const tbl of labelTables){
      if(!ACTIVE.has(tbl)) continue;
      jobs.push(loadLabelTable(tbl, a, b));
    }
    await Promise.all(jobs);
  }

  // ---------- Load / More ----------
  async function doLoad(reset=true){
    fromId=Number($start.value||1);
    chunk =Number($chunk.value||2000);
    toId  =fromId + chunk - 1;

    const t=await API.ticksRange(fromId,toId);
    buildTickState(reset?[]:ticks, t);
    await loadAllActiveLabels(fromId,toId);
    // Render fresh, fit Y to view only once on explicit Load
    render();
    adjustYAxisToView();
  }

  async function doMore(){
    if(!ticks.length) return;
    const {startId,endId}=getZoomIds();         // keep current view

    const nextFrom=toId+1, nextTo=toId+chunk;
    const t=await API.ticksRange(nextFrom,nextTo);
    buildTickState(ticks, t);
    await loadAllActiveLabels(nextFrom,nextTo);
    toId=nextTo;

    // Re-render and restore same IDs in view (no Y rescale)
    render({preserveZoomIds:{startId,endId}});
  }

  // ---------- Render ----------
  function render(opts={}){
    if(!chart) return;
    const preserve = opts.preserveZoomIds || null;
    const preserveYAxis = opts.preserveYAxis || null;

    // x categories
    const xCats = ticks.map(t=>String(t.id));

    // Build series
    const series=[];
    if(ACTIVE.has('mid')) series.push({name:'mid',type:'line',showSymbol:false,data:ticks.map(t=>t.mid)});
    if(ACTIVE.has('bid') && hasBid) series.push({name:'bid',type:'line',showSymbol:false,data:ticks.map(t=>t.bid)});
    if(ACTIVE.has('ask') && hasAsk) series.push({name:'ask',type:'line',showSymbol:false,data:ticks.map(t=>t.ask)});

    for(const tbl of labelTables){
      if(!ACTIVE.has(tbl)) continue;
      const pts=labelData.get(tbl)||[];
      series.push({name:tbl,type:'scatter',symbolSize:7,data:pts.map(p=>[p.idx,p.y,p.raw])});
    }

    // Update minimal pieces to avoid resetting zoom
    chart.setOption(
      {
        xAxis:{ data: xCats },
        series: series,
        legend:{ data: series.map(s=>s.name) },
        ...(preserveYAxis ? { yAxis: { min: preserveYAxis.min, max: preserveYAxis.max } } : {})
      },
      { replaceMerge:['series','legend'], lazyUpdate:false }
    );

    if(preserve){ restoreZoomByIds(preserve.startId, preserve.endId); }
  }

  // ---------- Y fit to current zoom ----------
  function adjustYAxisToView(){
    if(!ticks.length) return;
    const {startP,endP}=getZoomPercents();
    const n=ticks.length;
    const sIdx=Math.max(0, Math.floor(startP/100*n)), eIdx=Math.min(n-1, Math.ceil(endP/100*n));
    const slice=ticks.slice(sIdx,eIdx+1);
    const vals=[];
    if(ACTIVE.has('mid')) vals.push(...slice.map(t=>t.mid).filter(v=>v!=null));
    if(ACTIVE.has('bid') && hasBid) vals.push(...slice.map(t=>t.bid).filter(v=>v!=null));
    if(ACTIVE.has('ask') && hasAsk) vals.push(...slice.map(t=>t.ask).filter(v=>v!=null));
    if(!vals.length) return;
    const min=Math.min(...vals), max=Math.max(...vals), pad=Math.max(0.5,(max-min)*0.05);
    chart.setOption({ yAxis:{ min:min-pad, max:max+pad }});
  }

  // ---------- Boot ----------
  (async function(){
    await loadInitial();
  })();

})();
</script>
</body>
</html>
