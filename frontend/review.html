<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Review</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root { --bg:#0b1622; --fg:#d7e1ea; --mut:#8fa1b3; --grid:#243447; --axis:#5f7287;
          --mid:#9db4ff; --bid:#8bd6ff; --ask:#a8ffb5; --micro:#ffd166; --medi:#ef476f; --maxi:#06d6a0; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  .topbar{display:flex;gap:.75rem;align-items:center;padding:.5rem .75rem;border-bottom:1px solid var(--grid);position:sticky;top:0;background:rgba(11,22,34,.96);z-index:20}
  .topbar input{width:110px;background:#0e1b29;border:1px solid #294058;border-radius:6px;color:var(--fg);padding:.4rem .5rem}
  .btn{background:#12263a;border:1px solid #2d4a61;border-radius:8px;color:var(--fg);padding:.45rem .75rem;cursor:pointer}
  .btn:hover{background:#163048}
  .hint{margin-left:auto;color:var(--mut)}
  .legend{display:flex;gap:1rem;align-items:center;padding:.35rem .75rem;border-bottom:1px solid var(--grid)}
  .legend label{display:inline-flex;gap:.4rem;align-items:center;cursor:pointer}
  .chip{display:inline-block;width:.8rem;height:.8rem;border-radius:50%}
  .chip.mid{background:var(--mid)} .chip.bid{background:var(--bid)} .chip.ask{background:var(--ask)}
  .chip.micro{background:var(--micro)} .chip.medi{background:var(--medi)} .chip.maxi{background:var(--maxi)}
  #chart{height:calc(100vh - 104px)}
  svg{width:100%;height:100%;display:block}
  .axis path,.axis line{stroke:var(--axis)}
  .grid line{stroke:var(--grid)}
  .line{fill:none;stroke-width:1.5px}
  .line.mid{stroke:var(--mid)} .line.bid{stroke:var(--bid)} .line.ask{stroke:var(--ask)}
  .zig.micro{stroke:var(--micro)} .zig.medi{stroke:var(--medi)} .zig.maxi{stroke:var(--maxi)}
  .tooltip{position:absolute;pointer-events:none;background:#0f1f2f;border:1px solid #2d4a61;border-radius:8px;padding:.5rem .6rem;color:var(--fg);box-shadow:0 8px 24px rgba(0,0,0,.35)}
  .crosshair line{stroke:#6a7f94;stroke-dasharray:4 4}
  .toast{position:fixed;right:12px;bottom:12px;background:#1a2a3d;border:1px solid #334c66;color:#ffb4b4;padding:.5rem .7rem;border-radius:8px;display:none;z-index:50}
</style>
</head>
<body>
  <div class="topbar">
    <label>Start ID <input id="startId" type="number" value="1" /></label>
    <label>Chunk size <input id="chunk" type="number" value="2000" /></label>
    <button id="btnLoad" class="btn">Load</button>
    <button id="btnMore" class="btn">Load more (right)</button>
    <div class="hint">Legend toggles below • Zoom: <b>Shift+wheel</b> • Pan: <b>wheel</b></div>
  </div>
  <div class="legend" id="legend"></div>
  <div id="chart"></div>
  <div class="tooltip" id="tip" style="display:none"></div>
  <div class="toast" id="toast"></div>

<!-- d3 FIRST -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script>
/* ===================== helpers ===================== */
const $ = s => document.querySelector(s);
const niceInt = d3.format("~d");
const showToast = (msg) => { const t=$('#toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none', 4500); };
const fmtDT = ts => { const d=new Date(ts); return {date:d.toLocaleDateString(), time:d.toLocaleTimeString()}; };

/* ===================== endpoint auto-detect ===================== */
async function tryJSON(urls) {
  let lastErr;
  for (const u of urls) {
    try {
      const r = await fetch(u);
      if (r.ok) return await r.json();
    } catch (e) { lastErr=e; }
  }
  throw lastErr || new Error('No endpoint matched');
}

// Candidate builders
const ticksURLs = (start,limit) => [
  `/api/ticks?start=${start}&limit=${limit}`,
  `/ticks?start=${start}&limit=${limit}`,
  `/api/ticks?from=${start}&limit=${limit}`,
  `/ticks?from=${start}&limit=${limit}`,
];
const tablesURLs = [
  `/api/tables`,
  `/tables`,
  `/api/labels/tables`,
  `/labels/tables`,
];
const labelsURLs = (table,fromId,toId) => [
  `/api/labels?table=${encodeURIComponent(table)}&from=${fromId}&to=${toId}`,
  `/labels?table=${encodeURIComponent(table)}&from=${fromId}&to=${toId}`,
  `/api/labels/${encodeURIComponent(table)}?from=${fromId}&to=${toId}`,
  `/labels/${encodeURIComponent(table)}?from=${fromId}&to=${toId}`,
  `/api/labels?table=${encodeURIComponent(table)}&start_id=${fromId}&end_id=${toId}`,
  `/labels?table=${encodeURIComponent(table)}&start_id=${fromId}&end_id=${toId}`,
];

/* ===================== app state ===================== */
let ticks = [];
let ticksMap = new Map();
let loadedFrom = null, loadedTo = null;
let zoomX = null;
let layersMeta = {}; // { mid:{type:'tick',active:true}, ..., micro:{type:'zig',active:true}}
let zigData = {};    // { table:[{start_id,end_id,...}] }

const COLORS = { mid:'var(--mid)', bid:'var(--bid)', ask:'var(--ask)', micro:'var(--micro)', medi:'var(--medi)', maxi:'var(--maxi)' };

/* ===================== data fetchers (auto-fallback) ===================== */
async function fetchTicks(start, limit){ return tryJSON(ticksURLs(start,limit)); }
async function fetchTables(){
  const arr = await tryJSON(tablesURLs);
  // Normalize to array of names
  if (!arr) return [];
  if (Array.isArray(arr) && typeof arr[0]==='string') return arr.filter(n=>n!=='ticks');
  if (Array.isArray(arr) && arr[0]?.name) return arr.map(x=>x.name).filter(n=>n!=='ticks');
  return [];
}
async function fetchLabelsWindow(table, fromId, toId){
  return tryJSON(labelsURLs(table,fromId,toId));
}

/* ===================== load mechanics ===================== */
function indexTicks(arr){ for(const t of arr) ticksMap.set(t.id, t); }
function updateLoadedBounds(){ if (ticks.length){ loadedFrom=ticks[0].id; loadedTo=ticks[ticks.length-1].id; } }

async function doLoad(startId, chunk){
  try{
    const arr = await fetchTicks(startId, chunk);
    if (!Array.isArray(arr) || !arr.length){ showToast('No ticks returned'); return; }
    ticks = arr; ticksMap = new Map(); indexTicks(arr); updateLoadedBounds();
    await refreshZigsForWindow();
    zoomX = [loadedFrom, loadedTo];
    render();
  }catch(e){ console.error(e); showToast('Load failed'); }
}

async function doLoadMoreRight(){
  if (loadedTo==null) return;
  const chunk = +$('#chunk').value||2000;
  try{
    const arr = await fetchTicks(loadedTo+1, chunk);
    if (!arr.length) return;
    ticks = ticks.concat(arr); indexTicks(arr); updateLoadedBounds();
    const keep0 = Math.round(zoomX?.[0] ?? loadedFrom);
    const keep1 = Math.round(zoomX?.[1] ?? loadedTo);
    await refreshZigsForWindow();
    zoomX=[keep0,keep1];
    render();
  }catch(e){ console.error(e); showToast('Load more failed'); }
}

/* ===================== layers / legend ===================== */
async function initLayers(){
  layersMeta = {
    mid:{type:'tick',active:true},
    bid:{type:'tick',active:true},
    ask:{type:'tick',active:true},
  };
  try{
    const names = await fetchTables();
    const fromId = loadedFrom ?? 1, toId = loadedTo ?? (fromId+5000);
    for (const name of names){
      try{
        const rows = await fetchLabelsWindow(name, fromId, toId);
        const isZig = rows.length && ['start_id','end_id','start_ts','end_ts'].every(k => k in rows[0]);
        layersMeta[name] = {type: isZig ? 'zig' : 'tick', active: isZig}; // auto-enable zig
        if (isZig) zigData[name] = rows;
      }catch(e){ /* ignore non-readable tables */ }
    }
  }catch(e){ console.warn('tables probe failed', e); }
  buildLegend();
}

function buildLegend(){
  const c = $('#legend'); c.innerHTML='';
  for (const name of Object.keys(layersMeta)){
    const meta = layersMeta[name];
    const label=document.createElement('label');
    const chk=document.createElement('input'); chk.type='checkbox'; chk.checked=!!meta.active;
    chk.addEventListener('change', async ()=>{
      meta.active = chk.checked;
      await refreshZigsForWindow();
      render();
    });
    const chip=document.createElement('span'); chip.className='chip '+name;
    label.appendChild(chk); label.appendChild(chip); label.appendChild(document.createTextNode(' '+name));
    c.appendChild(label);
  }
}

async function refreshZigsForWindow(){
  const fromId = loadedFrom ?? 1, toId = loadedTo ?? (fromId+5000);
  const zigs = Object.keys(layersMeta).filter(n=>layersMeta[n].type==='zig' && layersMeta[n].active);
  for (const name of zigs){
    try{ zigData[name] = await fetchLabelsWindow(name, fromId, toId); }
    catch(e){ console.warn('zig fetch failed', name, e); }
  }
}

/* ===================== chart ===================== */
const svg = d3.select('#chart').append('svg');
const gMain = svg.append('g');
const gGrid = gMain.append('g').attr('class','grid');
const gXAxis = gMain.append('g').attr('class','axis');
const gYAxis = gMain.append('g').attr('class','axis');
const gLines= gMain.append('g').attr('clip-path','url(#clip)');
const gZigs = gMain.append('g').attr('clip-path','url(#clip)');
const gCross= gMain.append('g').attr('class','crosshair');

const defs = svg.append('defs');
defs.append('clipPath').attr('id','clip').append('rect');

let x = d3.scaleLinear();
let y = d3.scaleLinear();
let xAxis = d3.axisBottom(x).tickFormat(niceInt);
let yAxis = d3.axisLeft(y).ticks(8).tickFormat(niceInt);

function layout(){
  const {width,height} = svg.node().getBoundingClientRect();
  const m={t:18,r:26,b:34,l:48}, w=width-m.l-m.r, h=height-m.t-m.b;
  gMain.attr('transform',`translate(${m.l},${m.t})`);
  gXAxis.attr('transform',`translate(0,${h})`);
  defs.select('#clip rect').attr('width',w).attr('height',h);
  return {m,w,h};
}
function domainX(){
  if(!ticks.length) return [0,1];
  if(zoomX) return zoomX;
  return [ticks[0].id, ticks[ticks.length-1].id];
}
function computeYExtent(){
  const [x0,x1] = domainX();
  const vals=[];
  for (const k of ['mid','bid','ask']){
    if (layersMeta[k]?.active){
      for (const t of ticks){ if (t.id>=x0 && t.id<=x1 && t[k]!=null) vals.push(t[k]); }
    }
  }
  for (const name of Object.keys(layersMeta)){
    if (layersMeta[name]?.type!=='zig' || !layersMeta[name]?.active) continue;
    const legs = zigData[name]||[];
    for (const leg of legs){
      const a=ticksMap.get(leg.start_id), b=ticksMap.get(leg.end_id);
      if (a&&a.id>=x0&&a.id<=x1 && a.mid!=null) vals.push(a.mid);
      if (b&&b.id>=x0&&b.id<=x1 && b.mid!=null) vals.push(b.mid);
    }
  }
  if(!vals.length) return [0,1];
  let min=Math.min(...vals), max=Math.max(...vals);
  const pad=Math.max(0.25,(max-min)*0.05);
  min=Math.floor(min-pad); max=Math.ceil(max+pad);
  return [min,max];
}

function render(){
  const {w,h} = layout();
  const [x0,x1] = domainX();
  x.domain([x0,x1]).range([0,w]);
  const [y0,y1] = computeYExtent();
  y.domain([y0,y1]).range([h,0]).nice();

  // grid
  gGrid.selectAll('g.vert').data(x.ticks(8)).join(
    e=>e.append('g').attr('class','vert').append('line').attr('y1',0).attr('y2',h).attr('stroke','var(--grid)'),
    u=>u, x=>x.remove()
  ).attr('transform',d=>`translate(${x(d)},0)`);
  gGrid.selectAll('g.horz').data(y.ticks(8)).join(
    e=>e.append('g').attr('class','horz').append('line').attr('x1',0).attr('x2',w).attr('stroke','var(--grid)'),
    u=>u, x=>x.remove()
  ).attr('transform',d=>`translate(0,${y(d)})`);
  gXAxis.call(xAxis); gYAxis.call(yAxis);

  // tick lines
  const lineGen = k=> d3.line().x(d=>x(d.id)).y(d=>y(d[k])).defined(d=>d[k]!=null);
  for (const k of ['mid','bid','ask']){
    const on = layersMeta[k]?.active;
    const sel = gLines.selectAll(`path.line.${k}`).data(on?[ticks]:[]);
    sel.enter().append('path').attr('class',`line ${k}`).attr('stroke',COLORS[k])
        .merge(sel).attr('fill','none').attr('d', lineGen(k)(ticks));
    sel.exit().remove();
  }

  // zig polylines
  const zigNames = Object.keys(layersMeta).filter(n=>layersMeta[n]?.type==='zig' && layersMeta[n].active);
  const join = gZigs.selectAll('path.zig').data(zigNames, d=>d);
  join.enter().append('path').attr('class',d=>`zig ${d}`).attr('fill','none').attr('stroke-width',1.8)
      .attr('stroke',d=>COLORS[d]||'#bbb')
      .merge(join)
      .attr('d', name => {
        const legs=(zigData[name]||[]).slice().sort((a,b)=>a.start_id-b.start_id);
        const pts=[];
        for (const leg of legs){
          const a=ticksMap.get(leg.start_id), b=ticksMap.get(leg.end_id);
          if (!a||!b) continue;
          pts.push([x(a.id), y(a.mid)]);
          pts.push([x(b.id), y(b.mid)]);
        }
        if (!pts.length) return null;
        const p=d3.path(); p.moveTo(pts[0][0],pts[0][1]);
        for (let i=1;i<pts.length;i++) p.lineTo(pts[i][0],pts[i][1]);
        return p.toString();
      });
  join.exit().remove();

  drawCrosshair(w,h);
}

function drawCrosshair(w,h){
  const tip=$('#tip');
  svg.on('mousemove', ev=>{
    if (!ticks.length) return;
    const pt=d3.pointer(ev, svg.node());
    const xpix = pt[0]-48; // approx left margin
    const idGuess = Math.round(x.invert(Math.max(0,Math.min(w,xpix))));
    let t = ticksMap.get(idGuess);
    if (!t){
      const arr=ticks.map(d=>d.id);
      const i=d3.bisector(d=>d).center(arr, idGuess);
      t=ticks[i];
    }
    if (!t) return;
    const {date,time}=fmtDT(t.timestamp);
    let html=`<div><b>ID:</b> ${t.id} &nbsp; <b>Date:</b> ${date} &nbsp; <b>Time:</b> ${time}</div>`;
    for (const k of ['mid','bid','ask']) if (layersMeta[k]?.active && t[k]!=null) html+=`<div>${k}: <b>${t[k]}</b></div>`;
    tip.innerHTML=html; tip.style.display='block'; tip.style.left=(ev.clientX+14)+'px'; tip.style.top=(ev.clientY+14)+'px';
    gCross.selectAll('*').remove();
    const cy=t.mid!=null?y(t.mid):t.ask!=null?y(t.ask):t.bid!=null?y(t.bid):null;
    if (cy!=null){ const cx=x(t.id); gCross.append('line').attr('x1',cx).attr('x2',cx).attr('y1',0).attr('y2',h);
                   gCross.append('line').attr('x1',0).attr('x2',w).attr('y1',cy).attr('y2',cy); }
  }).on('mouseleave',()=>{ gCross.selectAll('*').remove(); $('#tip').style.display='none'; });
}

/* ===================== zoom/pan ===================== */
(function(){
  svg.node().addEventListener('wheel', (e)=>{
    if (!ticks.length) return;
    e.preventDefault();
    const {w}=layout();
    const [xmin,xmax]=domainX(); const span=xmax-xmin;
    const mouseX=d3.pointer(e, svg.node())[0]-48;
    const focal=x.invert(Math.max(0,Math.min(w,mouseX)));
    if (e.shiftKey){
      const factor=Math.exp(-e.deltaY*0.0015);
      let newMin=focal-(focal-xmin)*factor;
      let newMax=focal+(xmax-focal)*factor;
      newMin=Math.max(loadedFrom, Math.min(newMin,newMax-1));
      newMax=Math.min(loadedTo,   Math.max(newMax,newMin+1));
      zoomX=[Math.round(newMin),Math.round(newMax)];
    } else {
      const k=e.deltaY!==0?e.deltaY:e.deltaX;
      const shift=Math.round(k*span/120/6);
      let newMin=Math.max(loadedFrom, xmin+shift);
      let newMax=Math.min(loadedTo,   xmax+shift);
      if (newMax-newMin<1) newMax=newMin+1;
      zoomX=[newMin,newMax];
    }
    render();
  }, {passive:false});
})();

/* ===================== wire UI ===================== */
$('#btnLoad').addEventListener('click', async ()=>{
  const start=+$('#startId').value||1;
  const chunk=+$('#chunk').value||2000;
  await doLoad(start, chunk);
  await initLayers();
  render();
});
$('#btnMore').addEventListener('click', async ()=>{ await doLoadMoreRight(); });

/* ===================== first-run ===================== */
(async function(){
  try{
    await doLoad(+$('#startId').value||1, +$('#chunk').value||2000);
    await initLayers();
    render();
  }catch(e){ console.error(e); showToast('Initial load failed'); }
})();
</script>
</body>
</html>
