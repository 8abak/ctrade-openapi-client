<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ML Review — Price-Action Segments</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root{--bg:#0f172a;--panel:#111827;--ink:#e5e7eb;--muted:#94a3b8}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .toolbar{display:flex;gap:.75rem;align-items:center;padding:.6rem .8rem;background:var(--panel);position:sticky;top:0;z-index:2}
    .toolbar input[type="number"]{width:110px;background:#0b1220;border:1px solid #22304a;border-radius:8px;color:var(--ink);padding:.35rem .5rem}
    .toolbar button{background:#1f2a44;border:1px solid #334155;color:var(--ink);padding:.45rem .7rem;border-radius:8px;cursor:pointer}
    .toolbar button:hover{border-color:#4b5563}
    .layers{display:flex;align-items:center;gap:.65rem}
    .layers label{display:inline-flex;align-items:center;gap:.3rem;color:var(--muted)}
    .legend{padding:.3rem .8rem;color:var(--muted)}
    #wrap{height:calc(100% - 92px);display:flex;flex-direction:column}
    #chart{flex:1 1 auto;min-height:380px}
    .note{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="toolbar">
    <div>
      <div class="note">Start ID</div>
      <input id="startId" type="number" value="1" step="1" />
    </div>
    <div>
      <div class="note">Chunk size</div>
      <input id="chunk" type="number" value="2000" step="100" />
    </div>
    <button id="btnLoad">Load</button>
    <button id="btnMoreRight">Load more (right)</button>
    <div class="layers">
      <span class="note">Layers:</span>
      <label><input id="layMid" type="checkbox" checked /> mid</label>
      <label><input id="layBid" type="checkbox" /> bid</label>
      <label><input id="layAsk" type="checkbox" /> ask</label>
      <label><input id="layMaxi" type="checkbox" /> maxi</label>
      <label><input id="layMedi" type="checkbox" /> medi</label>
      <label><input id="layMicro" type="checkbox" checked /> micro</label>
    </div>
  </div>

  <div class="legend">Legend toggles below • Zoom: <b>Shift + wheel</b> • Pan: <b>wheel</b></div>

  <div id="wrap">
    <div id="chart"></div>
  </div>

  <script>
    // ----------- helpers -----------
    const $ = s => document.querySelector(s);
    function setBusy(on){ document.body.style.cursor = on ? 'progress' : 'default'; }
    function readControls(){
      startId = Number($('#startId').value);
      chunkSize = Number($('#chunk').value);
      endId = startId + chunkSize - 1;
    }
    async function fetchWithBody(url, init){
      const r = await fetch(url, init);
      const txt = await r.text();
      let payload = null;
      try { payload = txt ? JSON.parse(txt) : null; } catch { payload = txt; }
      if(!r.ok) {
        const msg = typeof payload === 'string' ? payload : (payload && (payload.detail || payload.message)) || r.statusText;
        throw new Error(`${r.status} : ${url}\n${msg ?? ''}`);
      }
      return payload;
    }

    // Try several query param shapes (some backends expect start_id/end_id, others start/end)
    async function fetchTicksSmart(sId, eId){
      const urls = [
        `/api/ticks?start_id=${sId}&end_id=${eId}`,
        `/api/ticks?start=${sId}&end=${eId}`,
        `/api/ticks/range?start_id=${sId}&end_id=${eId}`,
        `/api/ticks?from=${sId}&to=${eId}`
      ];
      let lastErr = null;
      for(const u of urls){
        try { return await fetchWithBody(u); }
        catch(e){ lastErr = e; /* try next */ }
      }
      throw lastErr ?? new Error('No ticks endpoint succeeded.');
    }

    async function fetchLabelsSmart(kind, sId, eId){
      // Keep your original route first, then common fallbacks
      const urls = [
        `/api/${kind}?start_id=${sId}&end_id=${eId}`,
        `/api/${kind}?start=${sId}&end=${eId}`,
        `/api/${kind}/range?start_id=${sId}&end_id=${eId}`
      ];
      let lastErr = null;
      for(const u of urls){
        try { return await fetchWithBody(u); }
        catch(e){ lastErr = e; }
      }
      // If label route truly doesn't exist, just return empty (page should still work)
      console.warn(`Label fetch failed for ${kind}:`, lastErr?.message || lastErr);
      return [];
    }

    // ----------- state -----------
    let startId   = Number($('#startId').value);
    let chunkSize = Number($('#chunk').value);
    let endId     = startId + chunkSize - 1;

    const tickMap = new Map(); // tickId -> { ts, mid, bid, ask, price }
    let midSeries = [], bidSeries = [], askSeries = [];

    const chart = echarts.init(document.getElementById('chart'));
    chart.setOption({
      darkMode:true, animation:false,
      tooltip:{ trigger:'axis', axisPointer:{ type:'cross' } },
      grid:{ left:60, right:20, top:30, bottom:110 },
      dataZoom:[ {type:'inside', filterMode:'none'}, {type:'slider', bottom:60, height:32} ],
      xAxis:{ type:'time', axisLabel:{color:'#9ca3af'} },
      yAxis:{ type:'value', scale:true, axisLabel:{color:'#9ca3af'} },
      series:[]
    });

    function priceLine(name, data, width=1){
      return { name, type:'line', showSymbol:false, smooth:0, lineStyle:{width}, data };
    }

    // Turn label rows into zigzag segments. Accepts either id-based or timestamp-based rows.
    function buildZigzagFromLabels(rows, name){
      const pts = [];
      for(const r of rows){
        let t1 = r.start_ts ?? r.start_time ?? null;
        let t2 = r.end_ts   ?? r.end_time   ?? null;
        let p1 = r.start_price ?? null;
        let p2 = r.end_price   ?? null;

        // Derive from ids if needed
        const sid = r.start_id ?? r.startId ?? r.sid ?? r.start_tick_id;
        const eid = r.end_id   ?? r.endId   ?? r.eid ?? r.end_tick_id;

        if((!t1 || p1==null) && sid && tickMap.has(sid)){
          const t = tickMap.get(sid);
          t1 = t.ts; p1 = (t.mid ?? t.price ?? t.bid ?? t.ask);
        }
        if((!t2 || p2==null) && eid && tickMap.has(eid)){
          const t = tickMap.get(eid);
          t2 = t.ts; p2 = (t.mid ?? t.price ?? t.bid ?? t.ask);
        }

        if(t1 && t2 && p1!=null && p2!=null){
          pts.push([t1,p1],[t2,p2],[null,null]); // null separates segments
        }
      }
      return {
        name,
        type:'line',
        connectNulls:false,
        showSymbol:true,
        symbolSize:4,
        lineStyle:{ width: name==='maxi'?2 : name==='medi'?1.5 : 1.2 },
        emphasis:{ disabled:true },
        z:10,
        data:pts
      };
    }

    async function loadTicksRange(sId, eId, append=false){
      const rows = await fetchTicksSmart(sId, eId);
      if(!append){ tickMap.clear(); midSeries=[]; bidSeries=[]; askSeries=[]; }
      for(const r of rows){
        const id  = r.id ?? r.tick_id ?? r.tickid ?? r.tickId;
        const ts  = r.ts ?? r.time ?? r.timestamp;
        const mid = r.mid ?? r.price ?? null;
        const bid = r.bid ?? null;
        const ask = r.ask ?? r.offer ?? null;
        if(id!=null && ts!=null){
          tickMap.set(id, { ts, mid, bid, ask, price: mid ?? bid ?? ask });
        }
        if(ts!=null){
          if(mid!=null) midSeries.push([ts, mid]);
          if(bid!=null) bidSeries.push([ts, bid]);
          if(ask!=null) askSeries.push([ts, ask]);
        }
      }
    }

    async function renderAll(){
      readControls(); setBusy(true);
      try{
        await loadTicksRange(startId, endId, false);

        const series = [];
        if($('#layMid').checked && midSeries.length) series.push(priceLine('mid', midSeries, 1.4));
        if($('#layBid').checked && bidSeries.length) series.push(priceLine('bid', bidSeries, 1));
        if($('#layAsk').checked && askSeries.length) series.push(priceLine('ask', askSeries, 1));

        const wantMaxi = $('#layMaxi').checked;
        const wantMedi = $('#layMedi').checked;
        const wantMicro= $('#layMicro').checked;

        const jobs = [];
        if(wantMaxi) jobs.push(fetchLabelsSmart('maxi', startId, endId).then(rows=>['maxi',rows]));
        if(wantMedi) jobs.push(fetchLabelsSmart('medi', startId, endId).then(rows=>['medi',rows]));
        if(wantMicro)jobs.push(fetchLabelsSmart('micro',startId, endId).then(rows=>['micro',rows]));

        const results = await Promise.allSettled(jobs);
        for(const r of results){
          if(r.status!=='fulfilled') continue;
          const [name, rows] = r.value;
          series.push(buildZigzagFromLabels(rows||[], name));
        }

        chart.setOption({ series }, { replaceMerge:['series'] });
      } catch(err){
        alert('Load failed: ' + err.message);
        console.error(err);
      } finally{
        setBusy(false);
      }
    }

    async function loadMoreRight(){
      readControls();
      const oldEnd = endId;
      const moreStart = oldEnd + 1;
      endId = oldEnd + chunkSize;

      setBusy(true);
      try{
        await loadTicksRange(moreStart, endId, true);

        const current = chart.getOption().series || [];
        const keep = current.filter(s => !['mid','bid','ask','maxi','medi','micro'].includes(s.name));

        if($('#layMid').checked) keep.push(priceLine('mid', midSeries, 1.4));
        if($('#layBid').checked) keep.push(priceLine('bid', bidSeries, 1));
        if($('#layAsk').checked) keep.push(priceLine('ask', askSeries, 1));

        const wantMaxi = $('#layMaxi').checked;
        const wantMedi = $('#layMedi').checked;
        const wantMicro= $('#layMicro').checked;

        const jobs = [];
        if(wantMaxi) jobs.push(fetchLabelsSmart('maxi', startId, endId).then(rows=>['maxi',rows]));
        if(wantMedi) jobs.push(fetchLabelsSmart('medi', startId, endId).then(rows=>['medi',rows]));
        if(wantMicro)jobs.push(fetchLabelsSmart('micro',startId, endId).then(rows=>['micro',rows]));
        const results = await Promise.allSettled(jobs);
        for(const r of results){
          if(r.status!=='fulfilled') continue;
          const [name, rows] = r.value;
          keep.push(buildZigzagFromLabels(rows||[], name));
        }

        chart.setOption({ series: keep }, { replaceMerge:['series'] });
      } catch(err){
        alert('Load failed: ' + err.message);
        console.error(err);
      } finally{
        setBusy(false);
      }
    }

    // UI events
    $('#btnLoad').addEventListener('click', renderAll);
    $('#btnMoreRight').addEventListener('click', loadMoreRight);
    ['#layMid','#layBid','#layAsk','#layMaxi','#layMedi','#layMicro'].forEach(id=>{
      $(id).addEventListener('change', renderAll);
    });

    // first paint
    renderAll();
  </script>
</body>
</html>
